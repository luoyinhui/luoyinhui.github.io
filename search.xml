<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ctf工具箱内容学习（未完成ing）</title>
      <link href="/2025/08/20/ctf%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/08/20/ctf%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>##暴力破解<br><img src="/images/1-1.png"></p><ol><li>Ziperello：暴力破解zip文件密码&#x2F;字典&#x2F;模板，但没有字典只能破解六位密码</li><li>pkcrck不知道为什么电脑不能打开可能是win32版本所以打不开，但网上没找到其他版本的（待）</li><li>ARCHPR：暴力破解&#x2F;字典&#x2F;掩码（不确定的地方打上？就行）</li></ol><hr><p>##文本处理（文件里叫“文本编辑器”）<br><img src="/images/1-2-1.png"></p><h2 id="一个常见的010，我加了一个winhex（本来自己电脑的加进去了）"><a href="#一个常见的010，我加了一个winhex（本来自己电脑的加进去了）" class="headerlink" title="一个常见的010，我加了一个winhex（本来自己电脑的加进去了）"></a>一个常见的010，我加了一个winhex（本来自己电脑的加进去了）</h2><p>##编码解码<br><img src="/images/1-3-1.png"></p><ol><li>因式分解（怎么用不清楚，作用不大先跳过，不敢删，放着</li><li>CyberChef：解码编码插件，有搜索功能</li><li>RSATool：网上没找到，遇到题目再说</li><li>Converter：功能有点鸡肋，尝试一个题目，直接卡死了</li><li>CTFcrack：额离谱实则皮下是stegsolve用来解LSB隐写的，具体使用看另一篇文章</li><li>与佛论禅（字面意思）</li><li>Base64（字面意思）</li><li>随波逐流（编码解码好东西）<br><img src="/images/suibo.png"></li><li>AZdecrypt：Z340黄道十二宫密码破解软件<br>使用：python移位+软件左框输入解密</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;&#x27;&#x27;</span><br><span class="line">%,,@*&gt;@?==%88%5</span><br><span class="line">,@%#@@90-7$^=*@</span><br><span class="line">17,(&gt;()1@##-\$40</span><br><span class="line">~,*6?#%#8#=75+1</span><br><span class="line">(*@*1%#&gt;,0@5)%?</span><br><span class="line">%*^=)&amp;&gt;=1%,+7&amp;#</span><br><span class="line">8681(+8*@@(,@@@</span><br><span class="line">#*=#\$3*#%,#%%,3</span><br><span class="line">,*+7,7+@===+)61</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"> </span><br><span class="line">s = s.strip()</span><br><span class="line"> </span><br><span class="line">arr = s.split(&#x27;\n&#x27;)</span><br><span class="line"> </span><br><span class="line">for n in range(1, 16):</span><br><span class="line">    tmp_s = &#x27;&#x27;</span><br><span class="line"> </span><br><span class="line">    for index, value in enumerate(arr):</span><br><span class="line">        i = (2 * index + n) % 15 - 1</span><br><span class="line">        tmp_s += value[i]</span><br><span class="line"> </span><br><span class="line">    print(tmp_s)</span><br></pre></td></tr></table></figure><ol start="10"><li>hashcat：cmd命令工具，原按钮无用，我加了exe文件按钮但具体用法是：##右键打开文件位置然后打开此处cmd##kali中自带！！！<br><a href="https://cloud.tencent.com/developer/article/2187201">https://cloud.tencent.com/developer/article/2187201</a><br>嗯，不是我现在用得上的高级东西，先浅放个使用方法网页，网页打不开去image文件夹找图片。<br><a href="https://www.cnblogs.com/Junglezt/p/16044372.html">https://www.cnblogs.com/Junglezt/p/16044372.html</a><br>后面搜索到的使用文档</li><li>CTF-Tools（原按钮失效，已删除重新添加exe文件可使用）<br><img src="/images/CTF-Tools.png"></li><li>破空（原来是无效按钮旧版3.0的，看到有3.3的（申请QQ群ing未替换））<blockquote><p>3.3功能：<br>1）查找到flag其他模式可以右键转换（结果去哪了还不清楚）<br>2）文件可以直接拖进去<br>3.3注意：<br>1）关键字编码即将flag的base64编码、16进制一起搜索，但只对字符格式有效；<br>2）网页查找智能用正则匹配</p></blockquote></li><li>CQR：二维码常见工具</li><li>Hash计算（字面意思吧。。遇到题目再说）</li><li>CaptfEncoder（原按钮无效，已删除重新添加exe文件可使用）：解码编码，有搜索功能</li><li>Apocalypso（原按钮无效，已删除重新添加exe文件可使用）：<br><img src="/images/A.png"></li><li>RSATool2v110（原按钮无效，已删除重新添加exe文件可使用）：<br>P、Q、R、D、E 分别就是 RSA 算法中的 p、q、N、d、e，右上角选择进制，注意：e 只有十六进制可用，左下角有一个 Factor N 的按钮，这是分解 N 的意思，点一下，会自动开始分解因数，得到 P、Q，Calc.D是计算按钮</li><li>MixedCS：DES加密软件</li><li>5bit编码：字面意思</li><li>SSLEye：编码解码工具，没有搜索功能<br><img src="/images/SSL.png"></li><li>在线。。。：字面意思</li><li>Ookbrainfuck：两种编码在线网站<br>Ook! has only three distinct syntax elements:<br>Ook.   &#x2F;   Ook?   &#x2F;   Ook!<br>Brainfuck语言用&gt; &lt; + - . , [ ]八种符号来替换C语言的各种语法和命令</li><li>brainfuck：字面意思吧但网页看不懂怎么操作</li><li>摩斯密码：好像打不开。。</li><li>quip词频分析：Quipqiup 是一个快速且自动化的密码求解器 by 埃德温 奥尔森。它可以解决常见的简单替换密码在报纸上，包括像 Cryptoquips 这样的谜题（在哪个词中边界被保留）。（遇到题目再说咯）</li><li>Playfair：（字面意思Playfair解码网站）</li><li>hillcipher：同上</li><li>熊说。。。：美化网站。。不知道怎么混进来的</li><li>malbolge：Malbolge 由 Ben Olmstead 于 1998 年发明，是一种深奥的编程语言，旨在尽可能难以编程。事实就是这样：-）（什么鬼东西哦编程在线网页？</li><li>Wingdings：将常规英文文本转换为可复制和粘贴的 Wingdings 文本</li><li>双hex：（字面意思two hex解码网站）</li><li>维吉利亚：<br><img src="/images/V.png"></li><li>切鲁：（混进来的鬼东西？</li><li>0宽1、0宽2、emoji-aes：打不开</li></ol><hr><p>##爆破工具<br><img src="/images/1-4.png"></p><ol><li>Bruter：爆破密码，ip+user用户名+dictionary</li><li>John：使用方式看下面网址，打不开看images文件夹，kali自带<br><a href="https://www.cnblogs.com/Junglezt/p/16048189.html">https://www.cnblogs.com/Junglezt/p/16048189.html</a></li><li>phpMyAdmin：字面意思暴力破解用户名密码</li><li>t00ls：看不懂搜不到跳过</li><li>。。。都看不懂，遇到题目再说好了</li></ol><hr><p>##密码工具<br>（太多了bushi先放着）</p><p><img src="/images/1-5.png"><br><img src="/images/1-6.png"><br><img src="/images/1-7.png"><br><img src="/images/1-8.png"><br><img src="/images/1-9.png"><br><img src="/images/1-10.png"><br><img src="/images/1-11.png"><br><img src="/images/1-12.png"><br><img src="/images/1-13.png"><br><img src="/images/1-14.png"><br><img src="/images/1-15.png"><br><img src="/images/1-16.png"><br><img src="/images/1-17.png"><br><img src="/images/1-18.png"><br><img src="/images/1-19.png"><br><img src="/images/1-20.png"><br><img src="/images/1-21.png"><br><img src="/images/1-22.png"><br><img src="/images/1-23.png"><br><img src="/images/1-24.png"><br><img src="/images/1-25.png"><br><img src="/images/1-26.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python代码和bat自动化存档</title>
      <link href="/2025/08/17/python%E4%BB%A3%E7%A0%81%E5%92%8Cbat%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AD%98%E6%A1%A3/"/>
      <url>/2025/08/17/python%E4%BB%A3%E7%A0%81%E5%92%8Cbat%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AD%98%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<ol><li><p>bat文件<br>@echo off<br>python “python文件绝对路径\文件名.py” &amp; pause<br>注意：<br>1）另存为时编码保存为ANSI，防止乱码<br>2）引号必须是英文引号</p></li><li><p>实现进制与字符串转换的python代码</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">astart = input(&#x27;输入待处理数字或字符串：&#x27;)</span><br><span class="line">#a = int(astart)</span><br><span class="line">bs = input(&#x27;输入选择：1=数字2=字符串&#x27;)</span><br><span class="line">b = int(bs)</span><br><span class="line">if b == 1:</span><br><span class="line">    c = int(input(&#x27;数字是1=二进制2=十进制3=十六进制4=八进制&#x27;))</span><br><span class="line">    if  c == 1:</span><br><span class="line">        a10 = int(astart,2)</span><br><span class="line">        print(&#x27;转为十进制为：&#x27;,a10,&#x27;\n转为八进制0o为：&#x27;,oct(a10),&#x27;\n转为十六进制0xc为：&#x27;,hex(a10))</span><br><span class="line">    elif c == 2:</span><br><span class="line">        a = int(astart)</span><br><span class="line">        a10 = a</span><br><span class="line">        print(&#x27;转为二进制0b为：&#x27;,bin(a),&#x27;\n转为八进制0o为：&#x27;,oct(a),&#x27;\n转为十六进制0xc为：&#x27;,hex(a))</span><br><span class="line">    elif c == 3:</span><br><span class="line">        a10 = int(astart,16)</span><br><span class="line">        print(&#x27;转为十进制为：&#x27;,a10,&#x27;\n转为八进制0o为：&#x27;,oct(a10),&#x27;\n转为十六进制0xc为：&#x27;,hex(a10))</span><br><span class="line">    elif c == 4:</span><br><span class="line">        a10 = int(astart,8)</span><br><span class="line">        print(&#x27;转为十进制为：&#x27;,a10,&#x27;\n转为八进制0o为：&#x27;,oct(a10),&#x27;\n转为十六进制0xc为：&#x27;,hex(a10))</span><br><span class="line">    by = a10.to_bytes((a10.bit_length() + 7) // 8, &#x27;big&#x27;)   # 大端</span><br><span class="line">    print(&#x27;转为字符串为：&#x27;,by)</span><br><span class="line">elif b == 2:</span><br><span class="line">    a2 = astart.encode(&#x27;utf-8&#x27;)</span><br><span class="line">    a2_10 = int.from_bytes(a2,&#x27;big&#x27;)</span><br><span class="line">    print(&#x27;转为二进制0b为：&#x27;,bin(a2_10),&#x27;\n转为八进制0o为：&#x27;,oct(a2_10),&#x27;\n转为十六进制0xc为：&#x27;,hex(a2_10),&#x27;\n转为十进制为：&#x27;,a2_10)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 笔记</title>
      <link href="/2025/08/17/js-%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/17/js-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>原先运行环境是网页，现在node能够模仿，所以本地运行需要下载node。<br>具体（在VScode中编辑）：<br>1新建html文件，！+Tab获得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 &gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;文件名.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><body>处需要手动编辑：1）h1+Tab获得<h1 ></h1>标签，中间可编辑；2）script+Tab获得<script></script>标签，中间可编辑，但正常使用引用.js文件方式编辑，具体如上述代码。<p>2 javascript语法粗略学习</p><ol><li>打印函数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;hello world&#x27;);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>变量：var全局变量,let可修改,const不可修改赋值对象</p></li><li><p>原生数据类型：string,number包括小数,boolean,null,undefined</p></li></ol><ol><li>undefined定义方法不是const而是：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let 变量名</span><br></pre></td></tr></table></figure><ol start="2"><li>类型检验方式：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof 变量名);</span><br></pre></td></tr></table></figure><p>此时null输出object<br>3) string<br>1、打印方法（新&#x2F;旧）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;123&#x27;+变量名);</span><br><span class="line">//模板字符串 新方法：</span><br><span class="line">const hello = `Myname is $&#123;变量名&#125;`; </span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure><p>2、内置方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量名.length</span><br><span class="line">//.toUpperCase()/.toLowerCase大小写</span><br><span class="line">//.substring(a,b)截取[a,b)；并且可以后面叠加（如大小写）</span><br><span class="line">//.split(&#x27;&#x27;)分割成数组 最小以字母为单位 ‘’内传入分割依据</span><br></pre></td></tr></table></figure><ol start="4"><li>数组</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1）构造方法</span><br><span class="line">//const 变量名 = new Array(1,2,3,4);</span><br><span class="line">//const 变量名 = [1,&#x27;1&#x27;,true];</span><br><span class="line">//2）索引</span><br><span class="line">//数组名[1]可直接获取/赋值</span><br><span class="line">//数组名.unshift(&#x27;dhkaju&#x27;)在最后加入数组</span><br><span class="line">//数组名.pop()删除最后</span><br><span class="line">//判断是否为数组Array.isArray(数组名)为bool值</span><br><span class="line">//数组名.indexOf(&#x27;数组内容&#x27;)为数组内容索引号</span><br></pre></td></tr></table></figure><ol start="5"><li>对象</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//const 对象名 = &#123;&#125;</span><br><span class="line">//属性可以TAB明确级别</span><br><span class="line">//调用</span><br><span class="line">//      对象名.属性名1，属性名2</span><br><span class="line">//      对象名.属性名1，属性名1.1</span><br><span class="line">//      对象名.属性名1[1]</span><br><span class="line">//剩余先跳过未学习</span><br></pre></td></tr></table></figure><ol start="6"><li>if</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件句)&#123;</span><br><span class="line">    内容</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    内容</span><br><span class="line">&#125;</span><br><span class="line">//条件句：===同时判断类型是否相同，==只判断内容</span><br><span class="line">//      ||或 &amp;&amp;且</span><br></pre></td></tr></table></figure><ol start="7"><li>三目运算符</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const color = x &gt; 10 ? &#x27;red&#x27; : &#x27;blue&#x27;;</span><br><span class="line">//x &gt; 10时color = &#x27;red&#x27;反之&#x27;blue&#x27;</span><br></pre></td></tr></table></figure><ol start="8"><li>swith条件语句</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch(color)&#123;</span><br><span class="line">    case &#x27;red&#x27;:</span><br><span class="line">        break;</span><br><span class="line">    default &#x27;blue&#x27;:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>for while循环</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0;i &lt;= 10; i++)&#123;</span><br><span class="line">    内容</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">let i = 0</span><br><span class="line">while(i &lt; 10)&#123;</span><br><span class="line">    内容</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六进制文件头尾特征</title>
      <link href="/2025/08/16/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4%E5%B0%BE%E7%89%B9%E5%BE%81/"/>
      <url>/2025/08/16/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B4%E5%B0%BE%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>##JPEG 图像文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFD8 FFE0 0010 4A46 4946 0001 0101 0047 ...</span><br></pre></td></tr></table></figure><p>FFD8 表示 JPEG 文件的开始，FFE0 代表应用程序特定标记，4A46 4946 表示 “JFIF” 标识。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... FFD9</span><br></pre></td></tr></table></figure><p>##PNG 图像文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8950 4E47 0D0A 1A0A ...</span><br></pre></td></tr></table></figure><p>PNG 文件的标准签名，其中 8950 4E47 对应 ASCII 编码的 %PNG。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... 0000 0000 4945 4E44 AE42 6082</span><br></pre></td></tr></table></figure><p>4945 4E44 对应 ASCII 编码的 IEND，AE42 6082 是 CRC 校验码。</p><p>##PDF 文档<br>以 %PDF 开头，具体的十六进制表示如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2550 4446 2D31 2E3X ...</span><br></pre></td></tr></table></figure><p>2550 4446 对应 ASCII 编码的 %PDF，2D31 2E3X 代表 PDF 的版本号。<br>文件尾通常包含 %%EOF 标记，具体的十六进制表示如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... 2525 454F 46</span><br></pre></td></tr></table></figure><p>2525 454F 46 对应 ASCII 编码的 %%EOF。</p><p>##DOC 文件（Microsoft Word 97-2003）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D0 CF 11 E0 A1 B1 1A E1 ...</span><br></pre></td></tr></table></figure><p>这个签名是 Microsoft 复合文件二进制格式（Compound File Binary Format, CFBF）的标志，常用于旧版 Microsoft Office 文档。<br>文件尾没有固定的模式，但通常包含结束标记，如 00 00 00 00。</p><p>##DOCX 文件&#x2F;ZIP文件（Microsoft Word 2007+）<br>DOCX 文件是基于 XML 的文件格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50 4B 03 04 ...</span><br></pre></td></tr></table></figure><p>这个签名表示 ZIP 压缩文件格式，因为 DOCX 文件实际上是 ZIP 压缩的 XML 文件。<br>文件尾通常以 ZIP 文件的结束标记结束：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... 50 4B 05 06</span><br></pre></td></tr></table></figure><p>##TXT 文件<br>没有固定的文件头，因为只是纯文本文件，有些文本文件可能以特定的字符编码（如 UTF-8）开始：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EF BB BF ...</span><br></pre></td></tr></table></figure><p>这是 UTF-8 编码的字节顺序标记（BOM）。<br>通常没有固定的文件尾。</p><p>##MOV 视频文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 14 66 74 79 70 71 74 20 20 ...</span><br></pre></td></tr></table></figure><p>66 74 79 70 对应 ASCII 编码的 ftyp，表示文件类型。<br>文件尾没有固定的模式，但通常包含结束标记，如 6D 64 61 74（mdat）。</p><p>##MP4 视频文件<br>MP4 文件的文件头与 MOV 文件类似，也以 ftyp 开头，但后续字节可能有所不同：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 18 66 74 79 70 6D 70 34 32 ...</span><br></pre></td></tr></table></figure><p>6D 70 34 32 对应 ASCII 编码的 mp42，表示 MPEG-4 第2版。<br>文件尾没有固定的模式，但通常包含结束标记，如 6D 64 61 74（mdat）。</p><hr><p>©著作权归作者所有：来自51CTO博客作者陈锋爱吃菠萝的原创作品，请联系作者获取转载授权，否则将追究法律责任（联系中）<br>十六进制文件头和文件尾：文件取证和恢复的关键<br><a href="https://blog.51cto.com/u_15763679/11200825">https://blog.51cto.com/u_15763679/11200825</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf 碎片知识整理</title>
      <link href="/2025/08/16/ctf-%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2025/08/16/ctf-%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]<br>#零碎知识点<br>##1. HTTP请求包（浏览器信息）<br>##2. 报错解决：error: externally-managed-environment<br>##3. 报错解决：E：invalid opertion install<br>##4. 常用命令：【kali】进入退出root命令</p><p>#零碎知识点<br>##1. HTTP请求包（浏览器信息）<br>我们先看看Request包的结构, Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。header和body之间有个空行，请求包的例子所示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET//请求行: 请求方法 请求URL HTTP协议/协议版本</span><br><span class="line">Host：//服务端的主机名</span><br><span class="line">User-Agent：//浏览器信息</span><br><span class="line">Accept：//客户端能接收的MIME</span><br><span class="line">Accept-Encoding：//是否支持流压缩</span><br><span class="line">Accept-Charset：//客户端字符编码集</span><br><span class="line">//空行,用于分割请求头和消息体</span><br><span class="line">//消息体,请求资源参数,例如POST传递的参数</span><br></pre></td></tr></table></figure><p>HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，增，改，删4个操作。我们最常见的就是GET和POST了。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息。</p><p>GET和POST的区别:</p><blockquote><ol><li>我们可以看到GET请求消息体为空，POST请求带有消息体。</li><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456。POST方法是把提交的数据放在HTTP包的body中。</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码</li></ol></blockquote><p>HTTP响应包（服务器信息）<br>我们再来看看HTTP的response包，他的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK//状态行</span><br><span class="line">Server: nginx/1.0.8//服务器使用的WEB软件名及版本</span><br><span class="line">Date:Date: Tue, 30 Oct 2012 04:14:25 GMT//发送时间</span><br><span class="line">Content-Type: text/html//服务器发送信息的类型</span><br><span class="line">Transfer-Encoding: chunked//表示发送HTTP包是分段发的</span><br><span class="line">Connection: keep-alive//保持连接状态</span><br><span class="line">Content-Length: 90//主体内容长度</span><br><span class="line">//空行 用来分割消息头和主体</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体</span><br></pre></td></tr></table></figure><p>Response包中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response。<br>HTTP&#x2F;1.1协议中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><blockquote><p>1XX 提示信息 - 表示请求已被成功接收，继续处理<br>2XX 成功 - 表示请求已被成功接收，理解，接受<br>3XX 重定向 - 要完成请求必须进行更进一步的处理<br>4XX 客户端错误 - 请求有语法错误或请求无法实现<br>5XX 服务器端错误 - 服务器未能实现合法的请求<br>————————————————<br>版权声明：本文为CSDN博主「hespecial」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_50376770/article/details/132438222">https://blog.csdn.net/m0_50376770/article/details/132438222</a></p></blockquote><p>##2. 报错解决：error: externally-managed-environment<br>方法1：安装venv虚拟环境（网上推荐但失败）<br>方法2：安装pipx，成功但使用不便<br>方法3：强行避免报错<br>具体：<br>原来安装代码：pip install 对象名<br>现在安装代码：pip install –break-system-packages 对象名</p><p>##3. 报错解决：E：invalid opertion install<br>更换源代码：<br>sudo add-apt-repository main<br>sudo add-apt-repository universe<br>sudo add-apt-repository restricted<br>sudo add-apt-repository multiverse<br>sudo apt-get update</p><p>##4. 常用命令：【kali】进入退出root命令<br>设置root密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>进入root：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>退出root：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure><p>##5. 零宽隐写<br><a href="https://tool.bfw.wiki/tool/1695021695027599.html">https://tool.bfw.wiki/tool/1695021695027599.html</a><br>注意：用ctrl+A复制</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如有侵权，私联方式：luoyinhui@protonmail.com</title>
      <link href="/2025/08/14/%E5%A6%82%E6%9C%89%E4%BE%B5%E6%9D%83%EF%BC%8C%E7%A7%81%E8%81%94%E6%96%B9%E5%BC%8F%EF%BC%9Aluoyinhui-protonmail-com/"/>
      <url>/2025/08/14/%E5%A6%82%E6%9C%89%E4%BE%B5%E6%9D%83%EF%BC%8C%E7%A7%81%E8%81%94%E6%96%B9%E5%BC%8F%EF%BC%9Aluoyinhui-protonmail-com/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>misc 笔记</title>
      <link href="/2025/08/13/misc-%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/13/misc-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]<br>##sstv</p><p>##sstv</p><ol><li>下载方法：pip install sstv<br>使用方法：<br>wav音频文件放到sstv根目录（C:\Windows\System32\sstv），打开cmd，输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd sstv</span><br><span class="line">sstv -d 文件名.wav -o result.png#输出图片名</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>RX-SSTV解码软件<br>下载地址：<a href="https://www.qsl.net/on6mu/rxsstv.htm">https://www.qsl.net/on6mu/rxsstv.htm</a><br>虚拟声卡e2eSoft<br>由于SSTV工具是根据音频传递图片信息，正常解法需要一台设备播放一台设备收音，所以需要一个虚拟声卡，还能避免杂音的干扰。<br>下载地址：<a href="https://www.e2esoft.cn/vsc/">https://www.e2esoft.cn/vsc/</a><br><img src="/images/sstv.jpeg"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件下载方法存档</title>
      <link href="/2025/08/12/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%E5%AD%98%E6%A1%A3/"/>
      <url>/2025/08/12/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%E5%AD%98%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>软件名：yaki<br>用途：ctf web<br>下载官网：<a href="https://yaklang.com/">https://yaklang.com/</a><br>使用文档：<a href="https://yaklang.io/products/intro/">https://yaklang.io/products/intro/</a><br><img src="/images/yaki.jpeg"></p><p>软件名：QRresearch<br>用途：ctf misc<br>下载地址：<a href="https://wwws.lanzouy.com/iRLUn11jc12h%E6%88%96%E8%80%85%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%94%B5%E8%84%91%E5%AD%98%E6%A1%A3%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E8%8E%B7%E5%8F%96">https://wwws.lanzouy.com/iRLUn11jc12h或者百度网盘电脑存档文件夹内获取</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 存档 </tag>
            
            <tag> 新电脑部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSB隐写题目解法</title>
      <link href="/2025/08/11/LSB%E9%9A%90%E5%86%99%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95/"/>
      <url>/2025/08/11/LSB%E9%9A%90%E5%86%99%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/LSB.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> LSB </tag>
            
            <tag> 图片隐写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsa 初步学习笔记</title>
      <link href="/2025/08/09/rsa-%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/08/09/rsa-%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1 因数，质数，余数</p><p>2 公钥，私钥<br>1）制作过程：<br><img src="/images/4.png"><br>2） 实际操作过程：<br><img src="/images/5.png"></p><p>3 具体题目解题过程中获得知识点<br>1）克拉默法则：<br>功能：确定线性方程组是否有解，以及解的唯一性。<br>重点！！！：只适用于方程组中未知量个数与方程个数相等的情形（具体原因？<br>基本形式：如果线性方程组的系数行列式不等于零，那么该方程组一定有唯一解。这个行列式可以通过将线性方程组的右端项b1, b2, …, bn分别代入原行列式的相应列元素中得到。<br>定理与推论：<br>定理1：如果线性方程组的系数行列式D不等于零，那么该方程组一定有唯一解。<br>定理2：如果线性方程组无解或有多个不同的解，那么它的系数行列式D必为零。<br>2）生日悖论<br><img src="/images/1.png"><br><img src="/images/2.png"><br>3）Floyd判圈算法（又称龟兔赛跑算法）<br>1 应用：<br>· 检测是否存在环<br>· 若环存在，可以计算出环的长度<br>· 若环存在，可以计算出环的起点<br>2 算法原理证明：<br><img src="/images/3.png"><br>如图1 已知兔子和乌龟同时从链表起点S出发，兔子速度是乌龟的两倍（乌龟每次向后移动1步，兔子移动每次向后移动2步），m是S和A之间的距离，n是A和B之间的距离，A是环的起点，L是环的长度，B是兔子、乌龟第一次相遇的点。</p><ol><li>环是否存在<br>结论：若兔子在达到链表尾部前，乌龟与兔子相遇了，则说明链表有环。<br>反证法：若环不存在，那么乌龟永远追不上兔子，那么在兔子到达链表尾部前乌龟不会和兔子相遇。若相遇了，则链表有环。</li><li>求环的长度<br>已知乌龟和兔子相遇时，它们必定都在环上。设它们第一次相遇在B点，相遇后兔子保持不动，乌龟保持每次移动一步的速度继续前行，第二次相遇时，环长度L&#x3D;第一次相遇后到第二次相遇时乌龟走过的路程。</li><li>求环的起点<br>设乌龟走过的全部路程为i，那么有<br>i &#x3D; m + n + aL （1）「a是乌龟绕过的环的圈数」<br>因为兔子的速度是乌龟的两倍，所以有<br>2i &#x3D; m + n + bL（2）「b是兔子绕过的环的圈数」<br>(2) – (1)可得：<br>i &#x3D; (b – a)L （3）<br>结合式子(1)、(3)可得 m + n + aL &#x3D; (b – a)L，所以有<br>m + n &#x3D; (b-2a)L（4）{因为m+n&gt;0且L&gt;0, 所以b-2a&gt;&#x3D;1}<br>所以可以得出结论：m + n &#x3D; 环长度L的正整数倍。（5）<br>当乌龟和兔子在B点第一次相遇后，让乌龟回到起点S，兔子仍在B，乌龟以每次1步的速度向前走，兔子以相同的速度绕环逆时针前进。当走了m步时，兔子和乌龟都正好在A处，即环的起点。<strong><strong>因为兔子相对于A点走了(n+m)步，由结论(5)可知A必然是环的起点。</strong></strong>【不懂】</li></ol><p>4 具体题目解题过程中获得工具<br>1）<a href="https://factordb.com/">https://factordb.com/</a><br>分解n工具，注意！！！点数字后就到上方框里了可以复制！！！（有点愚蠢但愚蠢的人没发现</p><p><strong><strong>具体题目：</strong></strong><br>· 来源：spc学长xc<br>基础rsa，在python中使用inverse()函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#from Crypto.Util.number import *</span><br><span class="line">#from secret import flag</span><br><span class="line">#m = bytes_to_long(flag)</span><br><span class="line">#p = getPrime(512)</span><br><span class="line">#q = getPrime(512)</span><br><span class="line">#e = 65537</span><br><span class="line">#n = p*q</span><br><span class="line">#c = pow(m,e,n)</span><br><span class="line">#print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">#print(f&#x27;q = &#123;q&#125;&#x27;)</span><br><span class="line">#print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">p = 12567387145159119014524309071236701639759988903138784984758783651292440613056150667165602473478042486784826835732833001151645545259394365039352263846276073</span><br><span class="line">q = 12716692565364681652614824033831497167911028027478195947187437474380470205859949692107216740030921664273595734808349540612759651241456765149114895216695451</span><br><span class="line">c = 108691165922055382844520116328228845767222921196922506468663428855093343772017986225285637996980678749662049989519029385165514816621011058462841314243727826941569954125384522233795629521155389745713798246071907492365062512521474965012924607857440577856404307124237116387085337087671914959900909379028727767057</span><br><span class="line"></span><br><span class="line">#最终解决方法：</span><br><span class="line">from Crypto.Util.number import long_to_bytes, inverse</span><br><span class="line">e = 65537          </span><br><span class="line">n = p * q</span><br><span class="line">t = (p - 1) * (q - 1)</span><br><span class="line">d = inverse(e, t)</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line"></span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag.decode())   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>· 来源：spc学长xc<br>题目提示：大数N的分解<br>题目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from serct import flag</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = 65537</span><br><span class="line">c = powmod(m, e, n)#加密结果    </span><br><span class="line">print(n)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"># 52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153</span><br><span class="line"># 48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069</span><br></pre></td></tr></table></figure><p>AI解法：<br>拿到题目后，我们手里只有n ，c ，e，但没有 p 和 q ，所以第一步就是分解 n。</p><ol><li>先直接上 yafu &#x2F; factordb<br>（注意！！！分解时要求P*Q&#x3D;N，且注意P跟Q的bit特征，在此题当中只有512bit）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = 72224896773450610791657349018700642791668283264384520670702825479122904864127</span><br><span class="line">q = 72224896773450610791657349018700642791668283264384520670702825479122904864239</span><br></pre></td></tr></table></figure><p>（这两个数只差 112，所以 yafu 的 ECM &#x2F; SIQS 都能秒破。）（yafu下载后卡死【待解决】</p><ol start="2"><li>有了 p、q，就能算私钥 d</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">n = 52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153</span><br><span class="line">c = 48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">p = 72224896773450610791657349018700642791668283264384520670702825479122904864127</span><br><span class="line">q = 72224896773450610791657349018700642791668283264384520670702825479122904864239</span><br><span class="line"></span><br><span class="line">assert p * q == n</span><br><span class="line">#校验等式是否成立</span><br><span class="line"></span><br><span class="line">phi = (p - 1) * (q - 1)#欧拉函数</span><br><span class="line">d = invert(e, phi)#e*d≡1mod phi</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>（这题就是典型的“p、q 距离太近”导致用 Fermat 方法或 ECM 就能秒分解。）（这两个方法是什么？</p><p>· 来源：spc学长xc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(b&#x27;flag&#123;******&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">r = getPrime(512)</span><br><span class="line"># 分别独立地生成 3 个 512 bit（≈154 位十进制）的随机强素数 p、q、r。这三个素数就是后面多素数 RSA 的因子。</span><br><span class="line"></span><br><span class="line">h1 = 1*p + 1*q + 1*r</span><br><span class="line">h2 = 2*p + 3*q + 3*r</span><br><span class="line">h3 = 9*p + 9*q + 6*r</span><br><span class="line">print( &quot;hint_of_pqr=&quot; , h1 , h2 , h3 )</span><br><span class="line"># h1,h2,h3可求出pqr的值</span><br><span class="line"></span><br><span class="line">e = getPrime(64)</span><br><span class="line"># 生成一个 64 bit 的随机素数 e，用作 RSA 公钥指数。</span><br><span class="line"></span><br><span class="line">a_big_prime = getPrime( 512 )</span><br><span class="line"># 再生成一个 512 bit 的随机素数，起名叫 `a_big_prime`。</span><br><span class="line"># 注意：这个名字有误导性，它并不是 RSA 模数 N 的因子，只是额外生成的一个素数，用来产生另一条“hint”（？什么鬼</span><br><span class="line"></span><br><span class="line">hint = pow(a_big_prime,e,2**512)</span><br><span class="line">#计算</span><br><span class="line"># pow（a,b,c）=（a^b）%c</span><br><span class="line"># 在 CTF 语境里，这往往暗示“partial key exposure”——低 512 位泄漏</span><br><span class="line"># 攻击者可用 Coppersmith/Howgrave-Graham lattice 方法恢复完整私钥。</span><br><span class="line"># 不过本题真正解密不需要它，因为 e 很小且 n 的因子我们已能求出。</span><br><span class="line"></span><br><span class="line">print( &quot;the big prime is: &quot; , a_big_prime )</span><br><span class="line">print( &quot;hint is:&quot; , hint )</span><br><span class="line"></span><br><span class="line">n = p*q*r</span><br><span class="line"># 构造一个 3 素数 RSA 模数 n，长度 3×512 = 1536 bit。</span><br><span class="line">c = pow( m , e , n )</span><br><span class="line">print( &quot;c=&quot; , c )</span><br><span class="line"># 输出密文 c</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">hint_of_pqr= 26205997351166240405785097231436009350807507606268828636742615246287109077466822241186639293389573242216311668227098054599788791116215571416316140409352427</span><br><span class="line">66860315641471130491119218972922785980480599406983109647358601581641695642878472456945137024883369147959034865118793676633880997281324220353834323524635144 213473629205254382083617791480463504155040467378518856042962121442859026373709762896295778597714884481459316375098621436229734548467857563069831689551454946</span><br><span class="line">the big prime is:  11557301053448817361014126921662226367639845395602185765021724910056663884113570410496382266851427507275779260616871464855286322325118092388982283547918921</span><br><span class="line">hint is: 10271913433365953528187318472631779008104540530202414129752768330046395509900224800993688431964630907432047820727638055487310601524087956924122431108238505</span><br><span class="line">c= 116569284047193403361251336983936346094224289856857789287062750599584928427772025697885153355908857327470083147465892652988245017837819503727301904206404536314951181113506280048949514352483259762138034268916332027429633274027588317302925270485836816591363962835119659624022139707163858477460375467148571163549410771927644341667962740112294140641187548649921303016157469076294782957230926056116058301134087751871726212821846406513780951057663400249479830993970711</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>自己解出来了但方法过于复杂，无参考价值，所以只保留学长wp作为存档。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Cryptodome.Util.number import long_to_bytes as l2b</span><br><span class="line">import sympy</span><br><span class="line"></span><br><span class="line">h1 =  26205997351166240405785097231436009350807507606268828636742615246287109077466822241186639293389573242216311668227098054599788791116215571416316140409352427</span><br><span class="line">h2 =  66860315641471130491119218972922785980480599406983109647358601581641695642878472456945137024883369147959034865118793676633880997281324220353834323524635144</span><br><span class="line">h3 =  213473629205254382083617791480463504155040467378518856042962121442859026373709762896295778597714884481459316375098621436229734548467857563069831689551454946</span><br><span class="line">a_big_prime =   11557301053448817361014126921662226367639845395602185765021724910056663884113570410496382266851427507275779260616871464855286322325118092388982283547918921</span><br><span class="line">hint =  10271913433365953528187318472631779008104540530202414129752768330046395509900224800993688431964630907432047820727638055487310601524087956924122431108238505</span><br><span class="line">c= 116569284047193403361251336983936346094224289856857789287062750599584928427772025697885153355908857327470083147465892652988245017837819503727301904206404536314951181113506280048949514352483259762138034268916332027429633274027588317302925270485836816591363962835119659624022139707163858477460375467148571163549410771927644341667962740112294140641187548649921303016157469076294782957230926056116058301134087751871726212821846406513780951057663400249479830993970711</span><br><span class="line">#解方程</span><br><span class="line">p = 3*h1 - h2</span><br><span class="line">r = (9*h1 - h3)//3</span><br><span class="line">q = h1 - p -r</span><br><span class="line"></span><br><span class="line">#解e</span><br><span class="line">e = sympy.discrete_log(2**512,hint,a_big_prime)</span><br><span class="line"></span><br><span class="line">#rsa算法</span><br><span class="line">n = p*q*r</span><br><span class="line">fain = (p-1)*(q-1)*(r-1)</span><br><span class="line">d = pow(e,-1,fain)</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(l2b(m))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> crypto </tag>
            
            <tag> rsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf writeup</title>
      <link href="/2025/08/09/ctf-writeup/"/>
      <url>/2025/08/09/ctf-writeup/</url>
      
        <content type="html"><![CDATA[<p>2025-08-09<br>题目类型：misc<br>题目来源：spc学长sq<br>解决步骤：<br>1 虚拟机VMware + kali linux中的binwalk工具，使用-e命令分解文件，得到缺三角的二维码<br>2 图片编辑补齐三角<br>3 扫码获得文本，使用社会主义核心价值观编码解开获得flag<br>反思：<br>难点主要只是工具配置和方向，所以还是要多问（笑）</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑求助存档</title>
      <link href="/2025/08/07/%E7%94%B5%E8%84%91%E6%B1%82%E5%8A%A9%E5%AD%98%E6%A1%A3/"/>
      <url>/2025/08/07/%E7%94%B5%E8%84%91%E6%B1%82%E5%8A%A9%E5%AD%98%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>2025-08-03<br><strong><strong>问题：openlist挂载卡在使用raildrive mount进行其集成网盘映射至本地文件夹一步</strong></strong><br>解决：取消勾选网络https:&#x2F;&#x2F;选项<br>反思：看攻略不够仔细，攻略中有这一步漏了</p><p>2025-08-03<br><strong><strong>问题：openlist自启动文件失败</strong></strong><br>解决：没有放在同级文件夹<br>反思：自动文件如.bat后缀文件，需要注意是否有放置位置要求</p><p>2025-08-03<br><strong><strong>问题：桌面出现观看视频名称，具体表现为网页观看任一视频出现名称在桌面左上角，且位于fence分类界面下方</strong></strong><br>解决：是wallpaper engine的壁纸问题，具体原因不清楚，有大佬怀疑壁纸随音乐律动模块把媒体控件拉过来了<br>反思：一开始一个个关闭桌面美化软件来确定问题来源时，漏了壁纸</p><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

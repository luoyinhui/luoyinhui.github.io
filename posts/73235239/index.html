<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【笔记】网络文章笔记 | 落殷回的博客</title><meta name="author" content="luoyinhui"><meta name="copyright" content="luoyinhui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="转载网上文章（有删改以及笔记，如有侵权请联系删除：yluo3383@gmail.com）">
<meta property="og:type" content="article">
<meta property="og:title" content="【笔记】网络文章笔记">
<meta property="og:url" content="https://luoyinhui.github.io/posts/73235239/index.html">
<meta property="og:site_name" content="落殷回的博客">
<meta property="og:description" content="转载网上文章（有删改以及笔记，如有侵权请联系删除：yluo3383@gmail.com）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luoyinhui.github.io/img/shouye.png">
<meta property="article:published_time" content="2025-12-05T12:44:49.000Z">
<meta property="article:modified_time" content="2026-01-21T05:05:31.813Z">
<meta property="article:author" content="luoyinhui">
<meta property="article:tag" content="转载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luoyinhui.github.io/img/shouye.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【笔记】网络文章笔记",
  "url": "https://luoyinhui.github.io/posts/73235239/",
  "image": "https://luoyinhui.github.io/img/shouye.png",
  "datePublished": "2025-12-05T12:44:49.000Z",
  "dateModified": "2026-01-21T05:05:31.813Z",
  "author": [
    {
      "@type": "Person",
      "name": "luoyinhui",
      "url": "https://luoyinhui.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/zhandian.png"><link rel="canonical" href="https://luoyinhui.github.io/posts/73235239/index.html"><link rel="preconnect"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.0"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css?v=7.0.1"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"DLCXYNBEA7","apiKey":"55cb2783d393395612712be2263ebaf1","indexName":"index","hitsPerPage":10,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":1000,"languages":{"author":"作者: luoyinhui","link":"链接: ","source":"来源: 落殷回的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.12.0',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【笔记】网络文章笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><style>
  .aplayer .aplayer-notice{display:none!important}
</style>
<link rel="stylesheet" href="/css/custom.css"><style>:root { --glass-opacity-light: 0.5; --glass-opacity-dark: 0.2; --post-glass-opacity-light: 0.8; --post-glass-opacity-dark: 0.2; }</style><!-- hexo injector head_end start --><style>/* CSS for Hexo Butterfly Updates Heatmap */
.updates-heatmap {
  margin-bottom: 20px;
  padding: 20px;
  background: var(--card-bg, #fff);
  border-radius: 8px;
  box-shadow: var(--card-box-shadow, 0 3px 8px 6px rgba(7, 17, 27, 0.05));
  width: 100%;
  overflow: hidden;
  color: var(--font-color, #333);
}

[data-theme='dark'] .updates-heatmap {
  background: var(--card-bg, #1d1d1f);
  color: var(--font-color, #F7F7FA);
}

.heatmap-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.heatmap-title {
  font-size: 1.2em;
  font-weight: bold;
  outline: none;
  border-bottom: 1px dashed transparent;
}

.heatmap-title:focus {
  border-bottom: 1px dashed #999;
}

.heatmap-legend {
  display: flex;
  align-items: center;
  font-size: 12px;
  color: var(--font-color, #888);
  gap: 4px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 2px;
}

.legend-color {
  width: 10px;
  height: 10px;
  border-radius: 2px;
  display: inline-block;
}

.legend-label {
  color: var(--font-color, #888);
  margin: 0 4px;
}

.heatmap-container {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.heatmap-months {
  display: grid;
  grid-template-columns: repeat(53, 1fr);
  margin-bottom: 5px;
  width: 100%;
}

.heatmap-month-label {
  font-size: 12px;
  color: var(--font-color, #888);
  grid-column: span 1;
  overflow: visible;
  white-space: nowrap;
}

.heatmap-grid {
  display: grid;
  grid-template-columns: repeat(53, 1fr);
  grid-template-rows: repeat(7, 1fr);
  grid-auto-flow: column;
  gap: 2px;
  width: 100%;
}

.heatmap-day {
  width: 100%;
  aspect-ratio: 1;
  border-radius: 2px;
  background-color: #ebedf0;
}

[data-theme='dark'] .heatmap-day {
  background-color: #2d333b;
}

.legend-color.level-0 { background-color: #ebedf0; }
[data-theme='dark'] .legend-color.level-0 { background-color: #2d333b; }

/* Green Theme */
.theme-green .level-1 { background-color: #9be9a8; }
.theme-green .level-2 { background-color: #40c463; }
.theme-green .level-3 { background-color: #30a14e; }
.theme-green .level-4 { background-color: #216e39; }

/* Blue Theme */
.theme-blue .level-1 { background-color: #a8d1ff; }
.theme-blue .level-2 { background-color: #63a7ff; }
.theme-blue .level-3 { background-color: #3079e0; }
.theme-blue .level-4 { background-color: #1a56ad; }

/* Pink Theme */
.theme-pink .level-1 { background-color: #ffc9c9; }
.theme-pink .level-2 { background-color: #ff8585; }
.theme-pink .level-3 { background-color: #e04545; }
.theme-pink .level-4 { background-color: #ad1a1a; }

/* Red Theme */
.theme-red .level-1 { background-color: #ffdce0; }
.theme-red .level-2 { background-color: #ff9b9b; }
.theme-red .level-3 { background-color: #ff4b4b; }
.theme-red .level-4 { background-color: #c91a1a; }

/* Orange Theme */
.theme-orange .level-1 { background-color: #ffe8cc; }
.theme-orange .level-2 { background-color: #ffb366; }
.theme-orange .level-3 { background-color: #ff8c1a; }
.theme-orange .level-4 { background-color: #cc6600; }

/* Purple Theme */
.theme-purple .level-1 { background-color: #e6ccff; }
.theme-purple .level-2 { background-color: #b366ff; }
.theme-purple .level-3 { background-color: #8c1aff; }
.theme-purple .level-4 { background-color: #6600cc; }

.updates-show-more-btn {
  text-align: center;
  cursor: pointer;
  padding: 10px 0;
  background: var(--card-bg, #fff);
  color: #49b1f5;
  border: 1px solid #ddd;
  border-radius: 8px;
  margin: 20px 0;
  width: 100%;
  transition: all 0.3s;
  user-select: none;
  display: block;
  visibility: visible;
  opacity: 1;
  font-size: 1.1em;
}

[data-theme='dark'] .updates-show-more-btn {
  background: var(--card-bg, #1d1d1f);
  color: #49b1f5;
  border: 1px solid #3d3d3d;
}

.updates-show-more-btn:hover {
  background: #f0f0f0;
  color: #FF7242;
}

[data-theme='dark'] .updates-show-more-btn:hover {
  background: #3d3d3d;
}

.year-label {
  text-align: center;
  margin-top: 10px;
  font-size: 0.9em;
  color: var(--font-color, #999);
}
</style><link rel="stylesheet" href="/css/swiper/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/swiper/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="落殷回的博客" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="落殷回的博客" type="application/rss+xml">
</head><body><div id="web_bg" style="background-image: url(/img/shouye.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-history"></i><span> 更新</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 社交</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/shouye.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">落殷回的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">【笔记】网络文章笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/updates/"><i class="fa-fw fas fa-history"></i><span> 更新</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-user-friends"></i><span> 社交</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【笔记】网络文章笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-05T12:44:49.000Z" title="发表于 2025-12-05 20:44:49">2025-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-21T05:05:31.813Z" title="更新于 2026-01-21 13:05:31">2026-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">18.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;作者已经&quot;,&quot;messageNext&quot;:&quot;天没有更新了！！可能内容过时哦，如果您发现错误并希望告诉作者，请评论区留言或者向yluo3383@gmail.com发送邮件。&quot;,&quot;postUpdate&quot;:&quot;2026-01-21 13:05:31&quot;}" hidden></div><h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2>
<ul>
<li>
<p>以下所有文章都在标题后标明来源网址，如有侵权请联系我的邮箱我将尽快回复并删除</p>
</li>
<li>
<p><a href="#zip%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8">ZIP已知明文攻击深入利用</a></p>
</li>
<li>
<p><a href="#pwn%E4%B9%8B%E6%9C%80relro%E6%9C%80%E5%B0%8F%E4%B8%91%E7%9A%84%E6%9C%BA%E5%88%B6">【pwn之最】RELRO:最小丑的机制</a></p>
</li>
<li>
<p><a href="#rc4">RC4</a></p>
</li>
<li>
<p><a href="#%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B9%8Bqr%E7%A0%81%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D">二维码之QR码生成原理与损坏修复</a></p>
</li>
<li>
<p><a href="#modbus%E4%B8%AD%E6%96%87%E7%89%88">MODBUS中文版</a></p>
</li>
<li>
<p><a href="#ctfshow-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-cs2026%E5%A4%A7%E4%BD%ACwp">CTFSHOW-2026元旦跨年欢乐赛-CS2026大佬wp</a></p>
</li>
<li>
<p><a href="#%E6%BC%94%E8%AE%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E7%8E%B0%E4%BB%A3web%E5%BA%94%E7%94%A8%E7%9A%84rce%E8%8B%B1%E6%96%87%E7%89%88%E6%96%87%E6%A1%A3">演讲《服务器端模板注入：现代Web应用的RCE》英文版文档</a></p>
</li>
<li>
<p><a href="#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-dns%E8%A7%A3%E9%87%8A-layer-fofa">信息收集-DNS解释-layer-fofa</a></p>
</li>
<li>
<p><a href="#cheatengine%E2%85%B6ce%E6%95%99%E7%A8%8B-%E8%87%AA%E5%8A%A8%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">【Cheatengine】Ⅶ：ce教程-自动汇编（基础知识）</a></p>
</li>
<li>
<p><a href="#wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95">《Wireshark网络分析就这么简单》</a></p>
</li>
</ul>
<h2 id="记事"><a class="markdownIt-Anchor" href="#记事"></a> 记事</h2>
<ul>
<li>URL转md网站：<br />
<a target="_blank" rel="noopener" href="https://devtool.tech/html-md">https://devtool.tech/html-md</a><br />
<a target="_blank" rel="noopener" href="https://www.helloworld.net/html2md">https://www.helloworld.net/html2md</a></li>
<li>待学习：</li>
<li><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/mitigation/canary/">https://ctf-wiki.org/pwn/linux/user-mode/mitigation/canary/</a></li>
</ul>
<h2 id="hexo的多种markdown渲染器对比分析"><a class="markdownIt-Anchor" href="#hexo的多种markdown渲染器对比分析"></a> hexo的多种markdown渲染器对比分析</h2>
<ul>
<li>转载自：<a target="_blank" rel="noopener" href="https://bugwz.com/2019/09/17/hexo-markdown-renderer/index.html?">https://bugwz.com/2019/09/17/hexo-markdown-renderer/index.html?</a></li>
</ul>
<h3 id="11-hexo-renderer-marked"><a class="markdownIt-Anchor" href="#11-hexo-renderer-marked"></a> 1.1、hexo-renderer-marked</h3>
<p>Hexo默认的Markdown的渲染器，针对于普通的Markdown的文章书写，该渲染器已经足够，但是由于不支持Mathjax，不支持插件扩展，不支持emoji表情，所以该渲染器也是介绍的渲染器中功能最弱的。</p>
<ul>
<li>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-renderer-marked">hexojs/hexo-renderer-marked</a></p>
</li>
<li>
<p>NPM地址：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-renderer-marked">hexo-renderer-marked</a></p>
<ul>
<li><code>版本</code>：2.0.0</li>
<li><code>最近提交</code>：a month ago</li>
<li><code>依赖</code>：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-util">hexo-util</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/marked">marked</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/strip-indent">strip-indent</a></li>
</ul>
</li>
<li>
<p>安装方式：<code>npm install hexo-renderer-marked —save</code></p>
</li>
</ul>
<h3 id="12-hexo-renderer-kramed"><a class="markdownIt-Anchor" href="#12-hexo-renderer-kramed"></a> 1.2、hexo-renderer-kramed</h3>
<p>基于hexo-renderer-marked二次开发的渲染器，完善了对Mathjax的支持，仍然不支持插件的扩展，不支持emoji表情。</p>
<ul>
<li>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/sun11/hexo-renderer-kramed">sun11/hexo-renderer-kramed</a></p>
</li>
<li>
<p>NPM地址：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-renderer-kramed">hexo-renderer-kramed</a></p>
<ul>
<li><code>版本</code>：0.1.4</li>
<li><code>最近提交</code>：2 years ago</li>
<li><code>依赖</code>：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-util">hexo-util</a>、<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/kramed">kramed</a>、<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/object-assign">object-assign</a>、<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/strip-indent">strip-indent</a></li>
</ul>
</li>
<li>
<p>安装方式：<code>npm install hexo-renderer-kramed --save</code></p>
</li>
</ul>
<h3 id="13-hexo-renderer-pandoc"><a class="markdownIt-Anchor" href="#13-hexo-renderer-pandoc"></a> 1.3、hexo-renderer-pandoc</h3>
<p>与hexo-renderer-marked类似，支持Mathjax语法，不仅可以渲染markdown，还支持textile，reStructedText和许多其他格式，仍然不支持emoji表情；内建的汇总文件<code>db.json</code>将来可能会非常大，同步到 Github 可能会比较慢，博客内建的搜索功能也可能会变得非常慢。</p>
<ul>
<li>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-renderer-pandoc">wzpan/hexo-renderer-pandoc</a></p>
</li>
<li>
<p>NPM地址：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-renderer-pandoc">hexo-renderer-pandoc</a></p>
<ul>
<li><code>版本</code>：0.1.4</li>
<li><code>最近提交</code>：2 years ago</li>
<li><code>依赖</code>：无</li>
</ul>
</li>
<li>
<p>安装方式：<code>npm install hexo-renderer-pandoc --save</code></p>
</li>
</ul>
<h3 id="14-hexo-renderer-markdown-it"><a class="markdownIt-Anchor" href="#14-hexo-renderer-markdown-it"></a> 1.4、hexo-renderer-markdown-it</h3>
<p>支持Mathjax语法（支持不太好），支持Markdown以及CommonMark语法，渲染速度比hexo-renderer-marked快，支持插件配置，支持标题带安全的id信息，支持脚注（上标，下标，下划线）。</p>
<ul>
<li>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo-renderer-markdown-it">hexojs/hexo-renderer-markdown-it</a></p>
</li>
<li>
<p>NPM地址：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></p>
<ul>
<li><code>版本</code>：3.4.1</li>
<li><code>最近提交</code>：4 years ago</li>
<li><code>依赖</code>：较多…</li>
</ul>
</li>
<li>
<p>安装方式：<code>npm i hexo-renderer-markdown-it —save</code></p>
</li>
</ul>
<h3 id="15-hexo-renderer-markdown-it-plus"><a class="markdownIt-Anchor" href="#15-hexo-renderer-markdown-it-plus"></a> 1.5、hexo-renderer-markdown-it-plus</h3>
<p>支持Katex插件并默认启用，默认启用插件列表：<code>markdown-it-emoji</code>，<code>markdown-it-sub</code>，<code>markdown-it-sup</code>，<code>markdown-it-deflist</code>，<code>markdown-it-abbr</code>，<code>markdown-it-footnote</code>，<code>markdown-it-ins</code>，<code>markdown-it-mark</code>，<code>@iktakahiro/markdown-it-katex</code>，<code>markdown-it-toc-and-anchor</code>。</p>
<ul>
<li>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus">CHENXCHEN/hexo-renderer-markdown-it-plus</a></p>
</li>
<li>
<p>NPM地址：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus</a></p>
<ul>
<li><code>版本</code>：1.0.4</li>
<li><code>最近提交</code>：a year ago</li>
<li><code>依赖</code>：<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/%40iktakahiro%2Fmarkdown-it-katex">@iktakahiro/markdown-it-katex</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clone">clone</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/highlight.js">highlight.js</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it">markdown-it</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-abbr">markdown-it-abbr</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-deflist">markdown-it-deflist</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-emoji">markdown-it-emoji</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-footnote">markdown-it-footnote</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-ins">markdown-it-ins</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-mark">markdown-it-mark</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-sub">markdown-it-sub</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-sup">markdown-it-sup</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/markdown-it-toc">markdown-it-toc</a>，<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/uslug">uslug</a></li>
</ul>
</li>
<li>
<p>安装方式：<code>npm i hexo-renderer-markdown-it-plus —save</code></p>
</li>
</ul>
<h2 id="zip已知明文攻击深入利用"><a class="markdownIt-Anchor" href="#zip已知明文攻击深入利用"></a> ZIP已知明文攻击深入利用</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/255145.html">https://www.freebuf.com/articles/network/255145.html</a></li>
</ul>
<h3 id="传统明文攻击概况"><a class="markdownIt-Anchor" href="#传统明文攻击概况"></a> 传统明文攻击概况</h3>
<ul>
<li>进行ZIP已知明文攻击，通常需要一个完整的明文文件。 而本文讨论的攻击方式只需要知道加密压缩包内容的12个字节，即可进行攻击破解降低了已知明文的攻击难度。同时，结合各类已知的文件格式，更扩宽了ZIP已知明文攻击的攻击面。</li>
<li>传统的已知明文攻击要成功需要三个条件：
<ul>
<li>完整的明文文件</li>
<li>明文文件需要被相同的压缩算法标准压缩（也可理解为被相同压缩工具压缩）</li>
<li>明文对应文件的加密算法需要是 ZipCrypto Store</li>
</ul>
</li>
<li>第三点是我们实际应用中常常会被忽略的。因竞赛中遇到的题目，都是提前设置好的
<ul>
<li>AES256-Deflate/AES256-Store加密的文件不适用于明文攻击。</li>
</ul>
</li>
<li>ZIP的加密算法大致分为两种ZipCrypto和AES-256,各自又分Deflate和Store。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZipCrypto Deflate</span><br><span class="line">ZipCrypto Store</span><br><span class="line">AES-256 Deflate</span><br><span class="line">AES-256 Store</span><br></pre></td></tr></table></figure>
<ul>
<li>ZipCrypto算是传统的zip加密方式。只有使用ZipCrypto Deflate /Store才可以使用 ZIP已知明文攻击进行破解。</li>
<li>传统的ZIP已知明文攻击利用，windows下可以使用AZPR，linux下可以使用pkcrack。</li>
</ul>
<h3 id="本文攻击方式"><a class="markdownIt-Anchor" href="#本文攻击方式"></a> 本文攻击方式</h3>
<ul>
<li>两个条件：
<ul>
<li>至少已知明文的12个字节及偏移，其中至少8字节需要连续。</li>
<li>明文对应的文件加密方式为ZipCrypto Store</li>
</ul>
</li>
<li>查看是ZipCrypto Store加密还是别的加密：用7z打开或者命令行工具可以查看加密算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7z l -slt XXX.zip</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>经测试：</li>
<li>Winrar（v5.80）、7zip（v19.00）默认状态下加密使用的就是AES256算法</li>
<li>360压缩（v4.0.0.1220）、好压（v6.2）使用的是ZipCrypto，不固定使用Store或Deflate（如果要固定使用ZipCrypto Store算法加密，可以在压缩的时候指定压缩方式为“存储”）。</li>
</ul>
</blockquote>
<h4 id="bkcrack实操"><a class="markdownIt-Anchor" href="#bkcrack实操"></a> bkcrack实操</h4>
<h5 id="加密文本破解"><a class="markdownIt-Anchor" href="#加密文本破解"></a> 加密文本破解</h5>
<ul>
<li>8+4的方式提取部分已知明文来进行攻击测试，</li>
<li>利用以下这部分明文，来进行攻击破解：*lag{16e3************<strong><strong><strong><strong>74f6</strong></strong></strong></strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备已知明文</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;lag&#123;16e3&quot;</span> &gt; plain1.txt   //连续的8明文</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;74f6&quot;</span> | xxd             //额外明文的十六进制格式，37346636</span><br><span class="line"><span class="comment">#攻击</span></span><br><span class="line">bkcrack -C flag_360.zip -c flag.txt -p plain1.txt -o 1 -x 29 37346636</span><br><span class="line"><span class="comment">#由于时间较长，为防止终端中断导致破解中断，可以加点小技巧</span></span><br><span class="line">bkcrack -C flag_360.zip -c flag.txt -p plain1.txt -o 1 -x 29 37346636 &gt; 1.<span class="built_in">log</span>&amp; //后台运行，结果存入1.<span class="built_in">log</span></span><br><span class="line">//加上<span class="keyword">time</span>参数方便计算爆破时间</span><br><span class="line"><span class="keyword">time</span> bkcrack -C flag_360.zip -c flag.txt -p plain1.txt -o 1 -x 29 37346636 &gt; 1.<span class="built_in">log</span>&amp;</span><br><span class="line">//查看爆破进度</span><br><span class="line"><span class="built_in">tail</span> -f 1.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注：-p 指定的明文不需要转换，-x指定的明文需要转成十六进制</li>
<li>提到的偏移都是指 “已知明文在加密前文件中的偏移”。</li>
<li>历时近16分钟，成功得到秘钥，这不是压缩包的加密密码，而是ZIP内部的三段秘钥，使用该秘钥进行解密：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C flag_360.zip -c flag.txt  -k b21e5df4 ab9a9430 8c336475 -d flag.txt</span><br></pre></td></tr></table></figure>
<h5 id="利用png图片文件头破解"><a class="markdownIt-Anchor" href="#利用png图片文件头破解"></a> 利用PNG图片文件头破解</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备已知明文</span></span><br><span class="line"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header</span><br><span class="line"><span class="comment">#攻击</span></span><br><span class="line"><span class="keyword">time</span> bkcrack -C png4.zip -c 2.png -p png_header -o 0 &gt;1.<span class="built_in">log</span>&amp;</span><br><span class="line"><span class="built_in">tail</span> -f 1.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<ul>
<li>近7分钟破解出秘钥：e0be8d5d 70bb3140 7e983fff</li>
<li>利用秘钥解密文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C png4.zip -c flag.txt -k e0be8d5d 70bb3140 7e983fff -d flag.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>jpg：<code>FFD8FFE000104A4649460001</code></li>
<li>gif：<code>474946383961</code> 或 <code>474946383761</code></li>
</ul>
<h5 id="利用zip格式破解"><a class="markdownIt-Anchor" href="#利用zip格式破解"></a> 利用zip格式破解</h5>
<ul>
<li>一个名为flag.txt的文件打包成ZIP压缩包后，你会发现文件名称会出现在压缩包文件头中，且偏移固定为30。且默认情况下，flag.zip也会作为该压缩包的名称。</li>
<li>所以，当一个加密压缩包中存在另一个ZIP压缩包时，且能够知道或猜测该压缩包内的文件名称时，可以尝试进行已知明文攻击。</li>
<li>将flag.zip与其他文件（选用一张图片2.png）一起用好压打包成加密ZIP压缩包：test5.zip</li>
<li>已知的明文片段有：
<ul>
<li>“flag.txt”  8个字节，偏移30</li>
<li>ZIP本身文件头：50 4B 03 04，4字节</li>
</ul>
</li>
<li>8+4，满足了破解的最低要求</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;flag.txt&quot;</span> &gt; plain1.txt     //-n参数避免换行，不然文件中会出现换行符，导致攻击失效</span><br><span class="line"><span class="keyword">time</span> bkcrack -C test5.zip -c flag.zip -p plain1.txt -o 30  -x 0 504B0304 &gt;1.<span class="built_in">log</span>&amp;</span><br><span class="line"><span class="built_in">tail</span> -f 1.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 利用秘钥解密：</span></span><br><span class="line">bkcrack -C test5.zip -c flag.zip -k b21e5df4 ab9a9430 8c336475  -d flag.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>想解密2.png，由于是ZipCrypto deflate加密的，所以解密后需要bkcrack/tool内的inflate.py脚本再次处理。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C test5.zip -c 2.png -k b21e5df4 ab9a9430 8c336475  -d 2.png</span><br><span class="line">python3 inflate.py &lt; 2.png &gt; 2_out.png</span><br></pre></td></tr></table></figure>
<h5 id="exe文件格式破解"><a class="markdownIt-Anchor" href="#exe文件格式破解"></a> EXE文件格式破解</h5>
<ul>
<li>如果加密ZIP压缩包出现以store算法存储的EXE格式文件，很容易进行破解。</li>
<li>大部分exe中都有这相同一段，且偏移固定为64：</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image.png" alt="alt text" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备明文</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000&quot;</span> | xxd -r -ps &gt; mingwen</span><br><span class="line"><span class="comment"># 攻击</span></span><br><span class="line"><span class="keyword">time</span> bkcrack -C nc64.zip -c nc64.exe -p mingwen -o64  &gt;1.<span class="built_in">log</span>&amp;</span><br><span class="line"><span class="comment"># 查看进度</span></span><br><span class="line"><span class="built_in">tail</span> -f 1.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 很快就解出了秘钥：b21e5df4 ab9a9430 8c336475</span></span><br><span class="line"><span class="comment"># 解密：</span></span><br><span class="line">bkcrack -C nc64.zip -c nc64.exe -k b21e5df4 ab9a9430 8c336475  -d nc64.exe</span><br></pre></td></tr></table></figure>
<h5 id="流量包pcapng格式解密"><a class="markdownIt-Anchor" href="#流量包pcapng格式解密"></a> 流量包pcapng格式解密</h5>
<ul>
<li>这里另外参考：
<ul>
<li><a target="_blank" rel="noopener" href="http://www.glun.top/2020/10/05/ctf02/">http://www.glun.top/2020/10/05/ctf02/</a></li>
<li>linux自带命令zipinfo，可以清楚的列出文件大小、压缩方式、压缩率等信息，加-v还能显示详细参数——<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/database/292628.html">鹤城杯misc-m1完整复现过程【钓鱼城杯量子加密原题】</a></li>
</ul>
</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-1.png" alt="alt text" /></p>
<blockquote>
<ul>
<li>红分是固定的：</li>
<li>Block Type始终为 0A0D0D0A；</li>
<li>Block Total Length是小端存储的Header长度，显然不会超过64KB，所以高两位都是 00 ；</li>
<li>Byte-Order Magic在小端机器上始终为4D3C2B1A；</li>
<li>Major Version目前只有 1000 ；Minor Version目前只有 0000 。</li>
<li>这样可以知道文件中的 4 + 10 字节内容，满足明文攻击的要求。</li>
<li>其实蓝色部分也是可以猜出来的：Section Length是可选字段，大多数软件（比如WireShark）在保存pcapng时会写入-1（即 8 个字节的FF）。</li>
</ul>
</blockquote>
<ul>
<li>00 00 4D 3C 2B 1A 01 00 00 00 FF FF FF FF FF FF FF FF</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;00004D3C2B1A01000000FFFFFFFFFFFFFFFF&quot;</span> | xxd -r -ps &gt; pcap_plain1</span><br><span class="line"><span class="keyword">time</span> bkcrack -C 3.zip -c capture.pcapng -p pcap_plain1 -o 6</span><br><span class="line">bkcrack -C 3.zip -c capture.pcapng  -k e33a580c  c0c96a81 1246d892  -d out.pcapng</span><br></pre></td></tr></table></figure>
<h5 id="网站相关文件破解"><a class="markdownIt-Anchor" href="#网站相关文件破解"></a> 网站相关文件破解</h5>
<ul>
<li>很容易找到突破口</li>
<li>例如：
<ul>
<li>robots.txt的文件开头内容通常是User-agent: *</li>
<li>html文件开头通常是 <!DOCTYPE html></li>
<li>xml文件开头通常是<?xml version="1.0" encoding="UTF-8"?></li>
</ul>
</li>
<li>在此以web.xml为例，web.xml 是网络程序中的一个很重要的配置文件。</li>
<li>常见xml文件头为：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li>
<li>网站目录肯定会涉及到多级目录，我们也同样进行模拟。在文件夹中创建一个二级目录“123”，并将一个web.xml放入该二级目录中，然后打包成加密ZIP。</li>
<li>攻击:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27;</span> &gt; xml_plain</span><br><span class="line"><span class="keyword">time</span> bkcrack -C xml.zip -c 123/web.xml -p xml_plain -o 0  //注意相对路径</span><br></pre></td></tr></table></figure>
<ul>
<li>解密：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bkcrack -C xml.zip -c 123/web.xml  -k e0be8d5d 70bb3140 7e983fff  -d web.xml</span><br></pre></td></tr></table></figure>
<h5 id="svg文件格式破解"><a class="markdownIt-Anchor" href="#svg文件格式破解"></a> SVG文件格式破解</h5>
<ul>
<li>xml格式的文件除了.xml以外，也包括.svg文件。SVG是一种基于XML的图像文件格式。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#攻击：</span></span><br><span class="line"><span class="comment">#已知明文</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot; &#x27;</span> &gt; plain.txt</span><br><span class="line">bkcrack -C secrets.zip -c spiral.svg -p plain.txt -o 0</span><br><span class="line"><span class="comment">#解密：</span></span><br><span class="line"><span class="comment">#解密 Store算法  直接解密即可</span></span><br><span class="line">bkcrack -C secrets.zip -c spiral.svg -k c4038591 d5ff449d d3b0c696 -d spiral_deciphered.svg</span><br><span class="line"><span class="comment">#解密 deflate算法</span></span><br><span class="line">bkcrack -C secrets.zip -c advice.jpg -k c4038591 d5ff449d d3b0c696 -d advice.deflate</span><br><span class="line"><span class="comment">#该文件使用了deflate算法压缩的，解码出来的是Deflate的数据流,因此须将其解压缩。</span></span><br><span class="line">python3 inflate.py &lt; advice.deflate &gt; advice.jpg</span><br></pre></td></tr></table></figure>
<h2 id="pwn之最relro最小丑的机制"><a class="markdownIt-Anchor" href="#pwn之最relro最小丑的机制"></a> 【pwn之最】RELRO:最小丑的机制</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_71015193/article/details/137607117">https://blog.csdn.net/m0_71015193/article/details/137607117</a></li>
</ul>
<h3 id="0-先简单介绍一下relro"><a class="markdownIt-Anchor" href="#0-先简单介绍一下relro"></a> 0、先简单介绍一下RELRO</h3>
<ul>
<li>ReLocation Read-Only，这是一种通过设置“重定位相关表”的权限为“只读”来防止其被修改的安全机制</li>
<li>这是个好思想，如果能够实施，一定能够防止大量的可能的攻击的吧，实在是太天才了！</li>
<li>linux的页机制：但是，我拒绝！</li>
</ul>
<h3 id="1-介绍一下relro的三个等级"><a class="markdownIt-Anchor" href="#1-介绍一下relro的三个等级"></a> 1、介绍一下RELRO的三个等级</h3>
<h5 id="1no-relro"><a class="markdownIt-Anchor" href="#1no-relro"></a> （1）no relro</h5>
<ul>
<li>关闭RELRO，放弃这趟jocker之旅~</li>
</ul>
<h5 id="2partial-relro"><a class="markdownIt-Anchor" href="#2partial-relro"></a> （2）partial relro</h5>
<ul>
<li>即“部分relro”，是gcc默认的relro等级，大多数pwn题就算这个等级，因为开高了会影响程序运行速度，开低了就emmmm也没有更低的等级了。</li>
<li>但是，因为页机制，这个等级下的relro成为了小丑。</li>
<li>先介绍一下这个等级本来的思想：
<ul>
<li>对于.dynamic表，直接将其列为只读，对于got表，got表的每个表项一开始是可写，被符号解析后，它就要被设置为是只读</li>
<li>实际实现上，遇到了一个绕不过去的底层问题</li>
</ul>
</li>
</ul>
<blockquote>
<p>操作系统通常以页（通常是4KB大小）为单位来管理内存的权限，也就是说它没法单独修改某个got表项的权限。<br />
也就是说——它在实现上，就变成了：必须got表的所有表项都被符号解析后，.dynamic和.got表才会被划入只读段</p>
</blockquote>
<ul>
<li>那就变小丑啦，你正常pwn题注入点的时候，肯定所有符号没有被解析完啊，你怎么说肯定有个exit没有被解析完吧~那你搞了个pratical relro，就变成没有意义了</li>
<li>正是：一波理论猛如虎，一看效果0杠五，寄。</li>
</ul>
<blockquote>
<p>同时，该ELF文件的各个部分会被重新排序。内数据段（internal data sections）（如.got，.dtors等）将被置于程序数据段（program’s data sections）（如.data和.bss）之前</p>
</blockquote>
<h5 id="3full-relro"><a class="markdownIt-Anchor" href="#3full-relro"></a> （3）full relro</h5>
<ul>
<li>该等级下延迟绑定与重定位将被禁止GOT表中的所有符号将在程序开始前被重定位好，然后程序开始运行时整个GOT表就被设置成只读了</li>
<li>但是这个时候plt跳板还是存在，也就是call还是会先转到plt跳板处</li>
<li>好，好，好，这样终于有用了，这样攻击者终于确实修改不了got表了，不过可惜这样坐会影响程序的启动速度，特别是一些大程序，会要启动大半天。</li>
<li>所以——选吧，诸君，to卡or to be 小丑…</li>
</ul>
<blockquote>
<p>另外link_map和_dl_runtime_resolve这两个函数将不会被装载到内存</p>
</blockquote>
<blockquote>
<p>此时尝试修改got表会遇到程序退出，退出码-11（SIGSEGV）表示遇到了段错误(试图写入只读内存区域)</p>
</blockquote>
<h3 id="2-最后介绍一下gcc编译指令"><a class="markdownIt-Anchor" href="#2-最后介绍一下gcc编译指令"></a> 2、最后介绍一下gcc编译指令</h3>
<ul>
<li><code>\-z norelro #关闭relro  </code></li>
<li>啥都不写就是partial relro</li>
<li><code>\-z relro #开启relro  </code></li>
</ul>
<blockquote>
<p>作者：载酒-下辈子不要学pwn <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv33601003/">https://www.bilibili.com/read/cv33601003/</a> 出处：bilibili</p>
</blockquote>
<h2 id="rc4"><a class="markdownIt-Anchor" href="#rc4"></a> RC4</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://l2x.gitbooks.io/understanding-cryptography/content/docs/chapter-1/rc4.html">https://l2x.gitbooks.io/understanding-cryptography/content/docs/chapter-1/rc4.html</a></li>
</ul>
<h3 id="rc4-2"><a class="markdownIt-Anchor" href="#rc4-2"></a> RC4</h3>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/RC4">RC4（来自Rivest Cipher 4）</a>由美国密码学家罗纳德·李维斯特（Ron Rivest）在1987年设计，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于<strong>对称加密算法</strong>。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。由于RC4算法存在弱点，2015年2月所发布的 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法。</p>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p>总结起来就3步：</p>
<ol>
<li>通过算法生成一个256字节的S-box。</li>
<li>再通过算法每次取出S-box中的某一字节K.</li>
<li>将K与明文做异或得到密文。</li>
</ol>
<p><strong>Step1. 密钥变换算法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">    S[i] := i</span><br><span class="line">endfor</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to <span class="number">255</span></span><br><span class="line">    j := (j + S[i] + key[i mod keylength]) mod <span class="number">256</span></span><br><span class="line">    swap values of S[i] <span class="keyword">and</span> S[j]</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure>
<p>先初始化S-box，使得S[0] = 0, S[1] = 1 … S[255] = 255。<br />
而后再打乱S-box，这一步会引入密钥。打乱后得到一个乱序的S-box。</p>
<p><strong>Step2. 伪随机算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">j := 0</span><br><span class="line">while GeneratingOutput:</span><br><span class="line">    i := (i + 1) mod 256</span><br><span class="line">    j := (j + S[i]) mod 256</span><br><span class="line">    swap values of S[i] and S[j]</span><br><span class="line">    K := S[(S[i] + S[j]) mod 256]</span><br><span class="line">    output K</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure>
<p>通过算法取出S-box中的一位K。</p>
<p><strong>Step3. 加密</strong></p>
<p>将上一步取出的K与明文当前字节做异或得到密文。明文的每一字节都会重复2，3步骤。</p>
<h2 id="二维码之qr码生成原理与损坏修复"><a class="markdownIt-Anchor" href="#二维码之qr码生成原理与损坏修复"></a> 二维码之QR码生成原理与损坏修复</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luogi/p/15469106.html#%E4%B8%8E%E6%8E%A9%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97">https://www.cnblogs.com/luogi/p/15469106.html#与掩码进行异或运算</a></li>
</ul>
<h3 id="二维码基础知识"><a class="markdownIt-Anchor" href="#二维码基础知识"></a> 二维码基础知识</h3>
<ul>
<li>一提到二维码，我们就会想起生活中处处都能见到的“二维码”，比如收款码、付款码、微信名片等等。但是严格意义来讲，这些码只是众多二维码中的一种，叫做QR码，也是现在我们使用最广泛的一种二维码。</li>
<li>二维码又称二维条码，是用某种特定的几何图形按一定规律在平面（二维方向上）分布的、黑白相间的、记录数据符号信息的图形；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。</li>
<li>二维码的种类有很多，除了我们常见的QR码外，使用比较广泛的还有：PDF417、DM、汉信码等。有兴趣的可以自行查阅</li>
</ul>
<h3 id="qr-码的格式与生成原理"><a class="markdownIt-Anchor" href="#qr-码的格式与生成原理"></a> QR 码的格式与生成原理</h3>
<h4 id="qr码的尺寸"><a class="markdownIt-Anchor" href="#qr码的尺寸"></a> QR码的尺寸</h4>
<ul>
<li>首先，我们先说一下QR码一共有40种尺寸。官方叫做版本Version(版本)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Version 1是21x21的矩阵；  </span><br><span class="line">Version 2是25x25的矩阵；  </span><br><span class="line">Version 3是29x29的矩阵...  </span><br></pre></td></tr></table></figure>
<ul>
<li>每增加一个version，就会增加4的尺寸（或者称单位，看后面就会理解），公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177的正方形。<br />
鉴于大家平时都已经习惯称呼QR码为二维码，我们后面的内容也就不一直强调QR码，而是称为二维码。大家只要明白，我们后面所说的二维码，都是指QR码即可。</li>
</ul>
<h4 id="qr码的格式"><a class="markdownIt-Anchor" href="#qr码的格式"></a> QR码的格式</h4>
<ul>
<li>QR码格式示例如下：</li>
</ul>
<p>英文版：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-3.png" alt="alt text" /></p>
<p>中文版：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-4.png" alt="alt text" /></p>
<h4 id="定位图案"><a class="markdownIt-Anchor" href="#定位图案"></a> 定位图案</h4>
<p>Position Detection Pattern（位置探测图形）是定位图案的一种，就是每个二维码都有的左上、左下和右上三个角的“回”字形的标志。用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个，因为三个就足以标识一个矩形了，用四个反而多余，且会使得能够表示的数据空间变小，扫描器在进行二维码扫描的时候会根据这三个定位标识符来更正二维码的坐标，方便进行扫描。这块区域的尺寸固定，无论是哪个版本的二维码，他的尺寸都是7*7的模块。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-5.png" alt="alt text" /><br />
Alignment Patterns（校正图形） 只有在Version 2以上（包括Version2）的二维码中需要这个东西，同样是为了定位用的。它的尺寸也是固定的，为5*5的模块。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-6.png" alt="alt text" /><br />
Timing Patterns（定位图形）也是用于定位的，是一单位宽的黑白交替点带，由黑色点起始和结束。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</p>
<h4 id="格式信息"><a class="markdownIt-Anchor" href="#格式信息"></a> 格式信息</h4>
<p>Format Information 存在于所有的版本中，用于存放一些格式化数据的，通过读取这部分的内容，可以知道当前二维码的纠错等级、掩码类别。主要内容为“纠错等级（2bit）+ 掩码类别（3bit）+ BCH code(10bit,用于纠错)”，然后这15个bits还要与101010000010010做XOR操作，主要是为了如果选用了00的纠错级别和000的Mask，从而造成全部为白色，这会增加扫描器的图像识别的困难。<br />
纠错等级的比特表示：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-7.png" alt="alt text" /><br />
为了增强二维码的容错能力，保证在一定的损坏范围内，不会影响数据的读取，共设计了两个区域来存放两条一模一样的格式信息。<br />
这15个bit在format information区域内的分布以及顺序如下（下图中数字的顺序就是这15个bit的存放顺序，应当注意的是这些数字表示的是位的高低，也就是当获取到格式信息15个bit长度的二进制字符串时，左边为高位，右边为低位，所以最左侧的二进制数字应该在14的位置，最右侧的二进制数字应该在0的位置）：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-8.png" alt="alt text" /></p>
<h4 id="版本信息"><a class="markdownIt-Anchor" href="#版本信息"></a> 版本信息</h4>
<p>Version Information 在&gt;= Version 7的版本中，预留两块3*6的区域存放一些版本信息。</p>
<h4 id="数据码字和纠错码字"><a class="markdownIt-Anchor" href="#数据码字和纠错码字"></a> 数据码字和纠错码字</h4>
<p>除了上述的那些地方，剩下的地方存放 Data Code 数据码字 和 Error Correction Code 纠错码字。我们后面就简称数据码和纠错码，就是最前面两张图的深灰色区域，一般数据都是从右下角开始填充，先填充数据码，数据码填充完毕之后再填充纠错码，以version1为例，数据的填充顺序，是这样的：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-9.png" alt="alt text" /><br />
当然，随着版本的升高，会有越来越多的校正图形掺杂在其中，这样的话，数据填充可能就不是这么规矩的矩形了，但是总体的填充顺序不会大变化，都是先右后左的顺序。具体的可参考官方的文档。</p>
<h3 id="数据编码与编码流程"><a class="markdownIt-Anchor" href="#数据编码与编码流程"></a> 数据编码与编码流程</h3>
<h4 id="qr码支持的数据编码"><a class="markdownIt-Anchor" href="#qr码支持的数据编码"></a> QR码支持的数据编码</h4>
<ul>
<li>Numeric mode（数字编码），从0到9。</li>
<li>Alphanumeric mode（字符编码），包括0-9，大写的A到Z（没有小写），以及符号“$ % * + – . / : 空格”。</li>
<li>Byte mode （字节编码），可以是0-255的ISO-8859-1字符。</li>
<li>Kanji mode （日文编码），也是双字节编码。</li>
<li>Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。</li>
<li>Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。</li>
<li>FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。</li>
</ul>
<p>下表是每个模式的编码相对应的“编号”。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-10.png" alt="alt text" /><br />
因为种类较多较复杂，而且为了方便大家理解，我们在这里值选择数字编码和字符编码举例，其它的编码，有兴趣的朋友可以查看官方文档。</p>
<h4 id="示例一"><a class="markdownIt-Anchor" href="#示例一"></a> 示例一：</h4>
<p>Numeric mode 数字编码，仅支持对从0到9的数字进行编码，也就是使用这个编码的二维码，扫描出来的内容只会是一串数字。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成长度为10位的二进制数，最后将这些二进制数据连接起来并在前面加上编码模式的编号和字符计数指示符（就是表示了被编码的信息有多少个字符），字符计数指示符的长度取决于编码的模式和所要编成二维码的版本，在数字编码中，字符计数指示符如下表对应的有10、12或14位：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-11.png" alt="alt text" /></p>
<p>比如在Version 1的尺寸下，纠错级别为H（表示纠错等级为“高”，纠错级别我们会在下面讲到）的情况下，我们要编码的内容为：01234567</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   （1）. 按照每3个字符一组，把上述数字分成三组: 012 345 67</span><br><span class="line">&gt;   （2）. 把三位数的转成10bit二进制:012 转成 0000001100；345 转成 0101011001；两位数的67 转成7bit的二进制： 1000011。</span><br><span class="line">&gt;   （3）. 把这3个二进制串起来: 0000001100 0101011001 1000011</span><br><span class="line">&gt;   （4）. 把数字的个数（字符计数指示符）转成二进制 (version 1，纠错等级H，编码模式为数字编码，所以字符计数指示符的长度是10bit): 8个数字的二进制是 0000001000</span><br><span class="line">&gt;   （5）. 把数字编码的标志0001和第4步的字符计数指示符的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="示例二"><a class="markdownIt-Anchor" href="#示例二"></a> 示例二：</h4>
<p>Alphanumeric mode 字符编码（也叫字母数字编码）。包括0-9，大写的A到Z（没有小写），以及符号“$ % * + – . / : 空格”。这些字符会映射成一个字符索引表。如下所示（两个表，中英文对照）：（其中的SP是空格，Char是字符，Value是其索引值）编码的过程是把字符转换为索引值，之后两两分组，按照特殊的算法转换成十进制的数值（这个算法，虽然简单，但是也是相当有想法，将前面的数值乘以45，加上后面的数值，组成一个十进制的数，这样在后期解码的时候，只用逆运算，用最后这个十进制的数除以45，得到的商和余数，就是原来的两个数），最后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而字符计数指示符需要根据不同的Version尺寸编成9,11或13个二进制（如上表）。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-12.png" alt="alt text" /><br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-13.png" alt="alt text" /><br />
在Version 1的尺寸下，纠错级别为H的情况下，对“AC-42”进行编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   （1）. 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)</span><br><span class="line">&gt;   （2）. 两两分组: (10,12) (41,4) (2)</span><br><span class="line">&gt;   （3）. 把每一组转成11bits的二进制:第一组(10,12)，计算公式 10*45+12 = 462 转成 00111001110 ；第二组(41,4)，计算41*45+4 = 1849 转成 11100111001 ；第三组(2) 等于 2 转成 00001 。</span><br><span class="line">&gt;   （4）. 把这些二进制连接起来：00111001110 11100111001 000010</span><br><span class="line">&gt;   （5）. 把字符的个数（字符计数指示符）转成二进制 (Version 1-H为9 bits ): 5个字符，5转成二进制就是 000000101</span><br><span class="line">&gt;   （6）. 在头上加上编码标识 0010 和第5步的字符计数指示符编码: 0010 000000101 00111001110 11100111001 000010</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="结束符和补齐符"><a class="markdownIt-Anchor" href="#结束符和补齐符"></a> 结束符和补齐符</h4>
<p>以上述示例一为基础，在编码结束后，我们得到了如下编码：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-14.png" alt="alt text" /><br />
然后，我们还要加上结束符，表示真正的额数据已经结束。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-15.png" alt="alt text" /><br />
按每组8个bit分组，如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有45个bit，所以，我们还要加上3个0，然后按8个bits分好组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00010000 00100000 00001100 01010110 01100001 10000000</span><br></pre></td></tr></table></figure>
<p>再然后，就是补齐符（padding bytes），如果添加上结束符之后还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复这两个bytes：11101100 00010001。（使用这两个字节的主要原因是，为了防止在填入数据时出现大片的深色或浅色区域，对扫描器产生干扰，使得二维码难以正常扫描），至于要补多少个补齐符，需要查看文档中相应的字符数和数据容量对应表，由于版本比较多，我们不一一列出，在官方文档中，我们示例相对应的是表7-表11。我们以下表为例：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-16.png" alt="alt text" /><br />
从表中，我们可以知道，version1-H的数据容量为9个数据码字（每个数据码字为8位），而我们上面已经有了6个数据码字，所以要补充三个8bit，补充完毕如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00010000 00100000 00001100 01010110 01100001 10000000 11101100 00010001 11101100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的每一组数据为一个数据码字，Data Codewords，现在也只是原始数据，还需要对其加上纠错码。</p>
<h4 id="纠错码"><a class="markdownIt-Anchor" href="#纠错码"></a> 纠错码</h4>
<p>上面我们提到了纠错级别，Error Correction Code Level，二维码中有四种级别的纠错（从低到高为L、M、Q、H），这就是为什么有人在二维码的中心位置加入图标，也依旧能够扫描的原因。（就是二维码残缺量不超过所对应的纠错等级允许的范围时，使用扫描工具依旧能扫描出内容的原因）。纠错等级对应的容错范围如下：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-17.png" alt="alt text" /><br />
即只要二维码的损坏面积没有超过这个范围，理论上是可以恢复损坏的数据的。</p>
<blockquote>
<ul>
<li>至于纠错码是如何计算的，这涉及到里德-所罗门纠错算法（Reed-Solomon error correction），里德-所罗门码是定长码。这意味着一个固定长度输入的数据将被处理成一个固定长度的输出数据。在最常用的（255,223）里所码中，223个里德-所罗门输入符号（每个符号有8个位元）被编码成255个输出符号。大多数里所错误校正编码流程是成体系的。这意味着输出的码字中有一部分包含着输入数据的原始形式。符号大小为8位元的里所码迫使码长（编码长度）最长为255个符号。标准的（255,223）里所码可以在每个码字中校正最多16个里所符号的错误。由于每个符号事实上是8个位元，这意味着这个码可以校正最多16个短爆发性错误。</li>
<li>里德-所罗门码，如同卷积码一样，是一种透明码。这代表如果信道符号在队列的某些地方被反转，解码器一样可以工作。解码结果将是原始数据的补充。但是，里所码在缩短后会失去透明性。在缩短了的码中，“丢失”的比特需要被0或者1替代，这由数据是否需要补足而决定。（如果符号这时候反转，替代的0需要变成1）。于是乎，需要在里所解码前对数据进行强制性的侦测决定（“是”或者“补足”）。</li>
</ul>
</blockquote>
<p>这两段话是我抄的，什么意思我也不懂，但我们有现成的python模块来运算出纠错码——python的reedsolo模块，我们只要会用就行了，数学好的朋友可以去研究具体算法的实现。</p>
<p>那么，哪个版本应该生成几个纠错码？我们可以对照官方文档中的纠错特性表，表13-表22。以下表为例：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-18.png" alt="alt text" /><br />
以版本1-H为例进行解释，从表中，我们可以清晰的知道，纠错码字数应该为17个，纠错的块数为1（表示这个版本要编码的数据只会分为一个数据块），（26,9,8）表示，这个版本的二维码总共可以存放26个码字，但是这26个码字中，有9个码字为数据码字，17个为纠错码字（8*2+1=17），8位纠错容量。每个表的下方附有注释信息：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-19.png" alt="alt text" /><br />
这也是为什么纠错码字数为r_2，当后面有一个箭头时，表示r_2之后还要加1。<br />
在给数据码字添加纠错码时，还有对数据码字分块的操作，因为version1的二维码对数据码字只分一个块，不够明显，所以我们采用网上的我所参考过的一个例子（现在不太容易找出处了，时间太久远了）：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-20.png" alt="alt text" /><br />
这个例子使用的是Version 5 Q纠错等级的二维码，从表中得知需要4个纠错块（2,2表示纠错块有两2组，每组2个），头一组的两个Blocks中各15个数据码字加上各18个纠错码字。<br />
因为二进制写起来会让表格太大，所以，都用了十进制来表示，我们简述一下下表是如何生成的：在将数据编码之后，每8位分开，形成我们需要的数据码字，然后再将数据码字按照规定分成15:15:16:16的四组，分别进行纠错码的运算，生成的纠错码字数都是18。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-21.png" alt="alt text" /><br />
最终将这些码字穿插放置。但是也不是随意穿插，是数据码字与数据码字穿插，纠错码字与纠错码字穿插。<br />
对于数据码字：把每个块的第一个数据码字先拿出来排列好，然后再取第一块的第二个，如此类推。上述示例中的数据码字Data Codewords如下：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-22.png" alt="alt text" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   我们先取第一列的：67， 246， 182， 70</span><br><span class="line">&gt;   然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247</span><br><span class="line">&gt;   如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… ………，38，6，50，17，7，236</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于纠错码，也是一样：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-23.png" alt="alt text" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，再把这两组放在一起（纠错码放在数据码之后）得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="remainder-bits剩余位"><a class="markdownIt-Anchor" href="#remainder-bits剩余位"></a> Remainder Bits（剩余位）</h4>
<p>最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看官方文档的表一（这里列出一部分）。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-24.png" alt="alt text" /></p>
<h3 id="掩码也叫掩模"><a class="markdownIt-Anchor" href="#掩码也叫掩模"></a> 掩码（也叫掩模）</h3>
<p>编码的步骤是完成了，但是要想生成一个完整的二维码，还需要先将现在所拥有的数据填入提前准备的空白模板后，选择一个合适的掩码，将原模板的数据与掩码进行异或运算，最后，再将format information填进去就生成了二维码。</p>
<p>掩码存在的意义：二维码是要拿来扫描的，而扫描怕的就是无法清晰地分辨出编码信息的每一位。要是二维码中黑白点数量不均，或是空间分布不均都会导致大色块区域的出现，而大色块区域的出现会增加扫描时定位的难度，从而降低扫描的效率。更严重的情况下，如果数据填入后碰巧出现了功能性标识，比如定位标识的图样，还会干扰正常功能性标识的作用，导致QR码无法扫描。<br />
在计算机科学中，掩码就是一个二进制串，通过和数据进行异或运算来变换数据。在QR码中，掩码也是通过异或运算来变换数据矩阵。QR码的掩码就是预先定义好的矩阵。QR标准通过生成规则定义了八个数据掩码(最后一个的编号，应该是111而不是110，图片错了)：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-25.png" alt="alt text" /></p>
<p>前面的三位二进制的数据就是每个模式掩码相对应的编号，这个信息也是要填入format information中的。具体的掩码图片是这样的：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-26.png" alt="alt text" /></p>
<p>从这个图我们就可以直观的看到每种掩码的模板样子，以掩码2（编号为010）为例，公式 j mod 3 = 0 就是表示从左边开始数，能被3整除的列，都要取逆（黑块变白块，白块变黑块），当然二维码的固定格式区域的信息是不用取逆的，所以要使用掩码2，需要取逆的列数为：0、3、6、9……。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-27.png" alt="alt text" /></p>
<p>当然，官方规定在进行异或时，原始的数据模板要与每个掩码模板进行异或运算后，要进行如下的规则进行计分（处罚），最后选择分数最低的一个作为最佳的掩码选择。这里我们只做了解，不深入。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-28.png" alt="alt text" /></p>
<h3 id="手绘二维码"><a class="markdownIt-Anchor" href="#手绘二维码"></a> 手绘二维码</h3>
<p>在这一小节，我计划用excel手动画出一个二维码，目标是使用手机能够扫描出“HELLO”。</p>
<h4 id="准备固定格式的填充模板"><a class="markdownIt-Anchor" href="#准备固定格式的填充模板"></a> 准备固定格式的填充模板</h4>
<p>利用前面所学到的内容，就已经足够我们手动来描绘出一个简单的二维码，我们要画的是一个version1且容错等级为H的二维码，从上面的基础知识中知道，版本1的二维码尺寸为21_21，所以我们整理出一个21_21的表格（最好将每一单位的模块都调整成正方形），并提前画好version1二维码中的固定格式部分。如下图，是一个version1版本的二维码的所有固定格式。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-29.png" alt="alt text" /></p>
<h4 id="进行数据编码"><a class="markdownIt-Anchor" href="#进行数据编码"></a> 进行数据编码</h4>
<p>接下来就是对数据进行编码，由于进行编码的内容“HELLO”，全部为大写字母，且不存在特殊符号。所以这里选用字符编码是最方便的。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-30.png" alt="alt text" /></p>
<p>根据前面的示例，可以很简单的知道如何来运算得到二进制的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从字符索引表中找到“HELLO”相对应的值。（17,14,21,21,24）</span><br><span class="line">2. 两两分组（17,14），（21,21），24</span><br><span class="line">3. 把每一组转换成11bit的二进制：（17,14）：17*45+14=779=0b01100001011 ；（21,21）：21\*45+21=966=0b01111000110 ；24：0b011000</span><br><span class="line">4. 把这些二进制连接起来：01100001011 01111000110 011000</span><br><span class="line">5. 把字符的个数转成二进制，5个字符（“HELLO”），000000101</span><br><span class="line">6. 再加上字符编码的标识0010，加起来就是0010 000000101 01100001011 01111000110 011000</span><br><span class="line">7. 再加上结束符0000：0010 000000101 01100001011 01111000110 011000 0000</span><br><span class="line">8. 按8bit重排，并补齐位数为8的倍数：00100000 00101011 00001011 01111000 11001100 00000000</span><br><span class="line">9. 添加补齐码：00100000 00101011 00001011 01111000 11001100 00000000 11101100 00010001 11101100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算纠错码"><a class="markdownIt-Anchor" href="#计算纠错码"></a> 计算纠错码</h4>
<p>根据纠错特性表来进行分块和添加纠错码：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-31.png" alt="alt text" /></p>
<p>由表我们知道，码字总数为26，纠错码字数为17，再加上我们之前编码好的数据9个8bit，刚好是26.</p>
<p>计算纠错码：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-32.png" alt="alt text" /></p>
<h4 id="码字整理"><a class="markdownIt-Anchor" href="#码字整理"></a> 码字整理</h4>
<p>整理一下得到的码字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   数据码字：32，43，11，120，204，0，236，17，236</span><br><span class="line">&gt;   纠错码字：109，149，156，18，217，41，246，36，42，84，46，225，190，218，251，27，196</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="数据填充"><a class="markdownIt-Anchor" href="#数据填充"></a> 数据填充</h4>
<p>得到所有的码字之后，就是简单但是麻烦的数据填充了：<br />
由于我们制作的是version1的二维码，所以不需要进行数据块的排序。直接按照如下的图片进行数据块的填充（先填充数据码字，再填充纠错码字）。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-33.png" alt="alt text" /></p>
<p>如：填充完第一个第二个数据码字的时候，应该是这个样子的：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-34.png" alt="alt text" /></p>
<p>全部填充完毕如下图，（剩下的粉红色的部分，是格式信息的位置，我们到后面再填充）：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-35.png" alt="alt text" /></p>
<p>将相应的format information信息填充进相应的区域。</p>
<ul>
<li>纠错码等级：H 对应的编码为：10</li>
<li>掩码类别：2 对应的编码为：010</li>
<li>BCH纠错比特：这里我们为了方便，直接查看对应关系，如下图，意思是一个二维码，如果它的纠错等级为H，所采用的的掩码为2，那么后面的二进制字符串即为它所对应的format information。参考地址：<a target="_blank" rel="noopener" href="https://www.thonky.com/qr-code-tutorial/format-version-tables#list-of-all-format-information-strings">https://www.thonky.com/qr-code-tutorial/format-version-tables#list-of-all-format-information-strings</a><br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-36.png" alt="alt text" /></li>
<li>最终15个bit的数据为： 001110011100111</li>
</ul>
<p>将其填充进format information数据区（注意填充顺序0-14所对应的是二进制的低位到高位）。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-37.png" alt="alt text" /></p>
<h4 id="与掩码进行异或运算"><a class="markdownIt-Anchor" href="#与掩码进行异或运算"></a> 与掩码进行异或运算</h4>
<p>我们前面提到，我们使用的是掩码2，也就是下面这个掩码：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-38.png" alt="alt text" /></p>
<p>j mod 3 = 0 意思就是从左往右数，凡是能够被3整除的列，颜色都要取反（黑变白，白变黑）。我们将要进行反色的列标注出来（这里我是用的是在对应的列下方标粉色）。注意：功能性区域的不用取逆，就是一开始准备的固定格式的地方和之后的format information区域的数据，不用取逆。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-39.png" alt="alt text" /></p>
<h4 id="手绘完成"><a class="markdownIt-Anchor" href="#手绘完成"></a> 手绘完成</h4>
<p>OK，大功告成。现在用我们的手机就可以扫描了：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-40.png" alt="alt text" /></p>
<h3 id="mma2015-misc400-qr二维码恢复挑战"><a class="markdownIt-Anchor" href="#mma2015-misc400-qr二维码恢复挑战"></a> MMA2015-MISC400-qr二维码恢复挑战</h3>
<p>学以致用，复现MMA2015-MISC400-qr的二维码恢复挑战的解题步骤，原版write-up地址为：<br />
<a target="_blank" rel="noopener" href="https://github.com/pwning/public-writeup/blob/master/mma2015/misc400-qr/writeup.md" title="https://github.com/pwning/public-writeup/blob/master/mma2015/misc400-qr/writeup.md">https://github.com/pwning/public-writeup/blob/master/mma2015/misc400-qr/writeup.md</a><br />
我的恢复思路也是跟着wp来的。</p>
<p>注：python官方下载的reedsolo模块版本为0.3，不是很好用，所以我们这次使用write-up中推荐的版本，下载解压后运行python <a target="_blank" rel="noopener" href="http://setup.py">setup.py</a> install即可。</p>
<h4 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h4>
<hr />
<p>题目给出的二维码如下图：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2020.cnblogs.com/blog/1154077/202110/1154077-20211027170003419-461153664.png" alt="image" /></p>
<p>根据对QR码的了解，知道这是一个25*25的二维码，也就是version2的二维码，从它能看见的部分我们可以得到format information的一部分信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">??????011011010</span><br></pre></td></tr></table></figure>
<h4 id="获取格式信息"><a class="markdownIt-Anchor" href="#获取格式信息"></a> 获取格式信息</h4>
<p>对照下面这个网址所给出的对应表，可以知道这个二维码使用了什么编码模式和使用了哪一个掩码<br />
<a target="_blank" rel="noopener" href="https://www.thonky.com/qr-code-tutorial/format-version-tables%5C#list-of-all-format-information-strings">https://www.thonky.com/qr-code-tutorial/format-version-tables\#list-of-all-format-information-strings</a><br />
【此网址已失效】<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-41.png" alt="alt text" /></p>
<p>经对照可知：</p>
<ul>
<li>完整的format information信息应该是：010111011011010</li>
<li>且可以得到的信息还有该二维码使用的掩码为：6，对应的计算公式：( (ij) mod 2 + (ij) mod 3 ) mod 2 = 0</li>
<li>所对应的纠错等级为：Q</li>
</ul>
<p>将被遮挡的固定信息部分以及format information信息补充完整。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-42.png" alt="alt text" /></p>
<h4 id="获取原始码字"><a class="markdownIt-Anchor" href="#获取原始码字"></a> 获取原始码字</h4>
<p>与相对应的掩码进行异或运算，得到原始的数据中的一部分数据码字和纠错码字。这个掩码对应的公式比较麻烦，且不容易计算，好在官方的文档中有提供各个掩码相对应的图案，如下图就是掩码6相对应的图案，如果不会计算公式，可以手动画一个与题目大小一样的掩码图，其对应的小图案大小是不变的，不同版本的二维码，只是小图案的数量不同：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-43.png" alt="alt text" /></p>
<p>将掩码应用到我们补充完的二维码上，翻转与掩码中深色区域相对应的区域的颜色，并用灰色将format information覆盖，方便读取数据，最后得到的如下图：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-44.png" alt="alt text" /></p>
<p>从右下角开始，按下图的蛇形顺序读取数据码字和纠错码字的信息，至于不同区域块的信息读取顺序，可以参考官方文档。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-45.png" alt="alt text" /><br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-46.png" alt="alt text" /><br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-47.png" alt="alt text" /><br />
且相对应的数据块分布应该如下图所示：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-48.png" alt="alt text" /></p>
<p>将全部可读的信息读取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00100000 10100010 10111000 00111010 01011001 10011010 10001000 ????????</span><br><span class="line">???????? ???????? ???????? ???????? ???????? ???????? ???????? ??00000?</span><br><span class="line">1??????? ???????? ???????? ???????? ???????? ??010001 00100100 1???????</span><br><span class="line">???????? ???????? ?????010 11000011 10000000 10101100 00010000 11100100</span><br><span class="line">10101010 10011001 01100110 ???????? ???????? ?????0?0 0000000? ????????</span><br><span class="line">???????? ???????? ???????? ????????</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="尽可能多地恢复数据"><a class="markdownIt-Anchor" href="#尽可能多地恢复数据"></a> 尽可能多地恢复数据</h4>
<p>根据官方文档的纠错特性表，可知version2-Q的纠错码字数有22个，数据码字数也有22个，在Q级别，它可以恢复不超过25%的损坏的字节，但是我们只有16个完整的字节，即超过63%的字节丢失，但是Reed-Solomon的纠错能力很强，如果它知道错误在哪里，那么纠错能力就强得多，可以纠正多达两倍的擦除。但是这个比例也才只到50%，还不能直接把丢失的数据恢复出来。所以我们要想办法恢复一部分字节使得达到所拥有的完整数据有22个字节这个最低要求。<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-49.png" alt="alt text" /></p>
<p>我们先将获得的可读取数据整理一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0010：【编码模式=字符编码（字母数字模式）】</span><br><span class="line">000010100：【9个bit长度的字符计数标识符=20个字符】</span><br><span class="line">01010111000：【FL】</span><br><span class="line">00111010010：【AG】</span><br><span class="line">11001100110：【 I】</span><br><span class="line">1010001000？：【S?】</span><br></pre></td></tr></table></figure>
<p>我们计算一下，22个数据码字，就是176个bit，而字符计数标识符表示总共有20个字符被编码，在编码的时候分为10组，每组11个bit，所以4+9+10*11=123个bit，也就是真正储存信息的数据码字共有123个bit，123/8=15余3，也就是结束符在第16个字节码，所以在第16个字节码的第4位开始，加上4个0（结束符），又因为8bit重组时需要补充为8的倍数，8-3-4=1，所以还需要加1个0。这时候总共也就16个数据码字，22-16=6，所以还要加上6个字节的补齐码，最终获得的数据码字的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00100000 10100010 10111000 00111010 01011001 10011010 10001000 ????????</span><br><span class="line">???????? ???????? ???????? ???????? ???????? ???????? ???????? ??000000</span><br><span class="line">11101100 00010001 11101100 00010001 11101100 00010001</span><br></pre></td></tr></table></figure>
<p>这样，我们就手动恢复了6个字节的数据，此时我们丢失的码字就只剩下22个了，正好达到了最低的要求。我们就可以使用纠错码恢复原本的数据。</p>
<h4 id="编写脚本恢复"><a class="markdownIt-Anchor" href="#编写脚本恢复"></a> 编写脚本恢复</h4>
<p>编写脚本利用python的reedsolo模块进行纠错（脚本文件已经存在与step3文件夹下）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import reedsolo</span><br><span class="line"></span><br><span class="line">reedsolo.init_tables(0x11d)</span><br><span class="line"></span><br><span class="line">qr_bytes = &#x27;&#x27;&#x27;00100000</span><br><span class="line">10100010</span><br><span class="line">10111000</span><br><span class="line">00111010</span><br><span class="line">01011001</span><br><span class="line">10011010</span><br><span class="line">10001000</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">??000000</span><br><span class="line">11101100</span><br><span class="line">00010001</span><br><span class="line">11101100</span><br><span class="line">00010001</span><br><span class="line">11101100</span><br><span class="line">00010001</span><br><span class="line">00100100</span><br><span class="line">1???????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">?????010</span><br><span class="line">11000011</span><br><span class="line">10000000</span><br><span class="line">10101100</span><br><span class="line">00010000</span><br><span class="line">11100100</span><br><span class="line">10101010</span><br><span class="line">10011001</span><br><span class="line">01100110</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">?????0?0</span><br><span class="line">00000000</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????</span><br><span class="line">????????&#x27;&#x27;&#x27;.split()</span><br><span class="line"></span><br><span class="line">b = bytearray()</span><br><span class="line">erasures = []</span><br><span class="line">for i, bits in enumerate(qr_bytes):</span><br><span class="line">    if &#x27;?&#x27; in bits:</span><br><span class="line">        erasures.append(i)</span><br><span class="line">        b.append(0)</span><br><span class="line">    else:</span><br><span class="line">        b.append(int(bits, 2))</span><br><span class="line">print erasures</span><br><span class="line">print type(b)</span><br><span class="line">for i in b :</span><br><span class="line">	print &#x27;%x&#x27; % i</span><br><span class="line"></span><br><span class="line">mes, ecc = reedsolo.rs_correct_msg(b, 22,erase_pos=erasures)</span><br><span class="line">for c in mes:</span><br><span class="line">	print &#x27;&#123;:08b&#125;&#x27;.format(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到全部的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00100000 10100010 10111000 00111010 01011001 10011010 10001000 00101111</span><br><span class="line">10000110 11100010 10110110 10011001 01001010 11000011 00010101 00000000</span><br><span class="line">11101100 00010001 11101100 00010001 11101100 00010001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="拆分和解码"><a class="markdownIt-Anchor" href="#拆分和解码"></a> 拆分和解码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   0010 [编码模式=字符编码]</span><br><span class="line">&gt;   000010100 [字符长度=20]</span><br><span class="line">&gt;   01010111000 [&quot;FL&quot;]</span><br><span class="line">&gt;   00111010010 [&quot;AG&quot;]</span><br><span class="line">&gt;   11001100110 [&quot; I&quot;]</span><br><span class="line">&gt;   10100010000 [&quot;S &quot;]</span><br><span class="line">&gt;   01011111000 [&quot;G+&quot;]</span><br><span class="line">&gt;   01101110001 [&quot;JQ&quot;]</span><br><span class="line">&gt;   01011011010 [&quot;GA&quot;]</span><br><span class="line">&gt;   01100101001 [&quot;H:&quot;]</span><br><span class="line">&gt;   01011000011 [&quot;FW&quot;]</span><br><span class="line">&gt;   00010101000 [&quot;3X&quot;]</span><br><span class="line">&gt;   0000 [结束符]</span><br><span class="line">&gt;   0 [8bit重组时补充的bit]</span><br><span class="line">&gt;   11101100 00010001 [补齐码]</span><br><span class="line">&gt;   11101100 00010001</span><br><span class="line">&gt;   11101100 00010001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二维码恢复挑战-二维码恢复工具"><a class="markdownIt-Anchor" href="#二维码恢复挑战-二维码恢复工具"></a> 二维码恢复挑战-二维码恢复工具</h3>
<p>二维码恢复工具：qrazybox<br />
工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/Merricx/qrazybox/tree/master/js">https://github.com/Merricx/qrazybox/tree/master/js</a></p>
<p>声明：<br />
本次使用的题目是某次CTF比赛的题目，但是具体是哪次比赛的，我也不是很清楚。只是某天在群里划水的时候，间接得到了题目的文件，所以尝试进行了解答；由于是之后进行的回忆，自己也懒得再做一遍了，所以只能依靠当时解题时的一些零碎数据来拼凑一下完整的过程（我当时是手工做的，很费时间）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; QRazyBox 是一个基于 Web 的应用程序（工具包），用于分析和恢复损坏的二维码。</span><br><span class="line">&gt; QRazyBox 允许您通过使用类似 Paint 的编辑器重新绘制和重建二维码来恢复二维码。</span><br><span class="line">&gt; 它还提供了几个子工具来帮助您更快、更高效地分析和恢复。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总体来说，这是一个辅助类型的工具，可以帮助你更好的分析损坏的QR码。</p>
<h4 id="题目分析-2"><a class="markdownIt-Anchor" href="#题目分析-2"></a> 题目分析</h4>
<p>这个题目的文件如下：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-50.png" alt="alt text" /></p>
<p>可以看到损坏的程度并不高（至少比上一道题少），我们先尝试手工读取内容，根据前面的知识，我们可以得知：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-51.png" alt="alt text" /></p>
<p>那么可以尝试将它画在excel表格中，并将缺失的定位点和格式信息补上：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-52.png" alt="alt text" /></p>
<h4 id="整理已知信息"><a class="markdownIt-Anchor" href="#整理已知信息"></a> 整理已知信息</h4>
<p>手动解码的步骤我们就不在这里描述了，我们直接放出解码时需要的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   版本：3</span><br><span class="line">&gt;   格式信息：101000100100101</span><br><span class="line">&gt;   纠错等级： M </span><br><span class="line">&gt;   掩码编号： 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="恢复初始数据"><a class="markdownIt-Anchor" href="#恢复初始数据"></a> 恢复初始数据</h4>
<p>计算掩码的行数与列数（python）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for row in range(29):</span><br><span class="line">	for column in range(29):</span><br><span class="line">		if(( ((row * column) % 2) + ((row * column) % 3) ) % 2 == 0):</span><br><span class="line">			print(str(row)+&#x27;--&#x27;+str(column)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>手动将掩码反色的点返回来：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-53.png" alt="alt text" /></p>
<h4 id="读取数据码字"><a class="markdownIt-Anchor" href="#读取数据码字"></a> 读取数据码字</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01000001 11000111 10100110 10100110 00110111</span><br><span class="line">01000110 01100111 10110111 10010011 00000111</span><br><span class="line">01010101 11110110 01100011 00010110 11100110</span><br><span class="line">01000101 11110110 11010110 01010101 11110011</span><br><span class="line">00010110 11100101 11110111 00010111 00100110</span><br><span class="line">00110011 00000110 01000011 00110111 11010000</span><br><span class="line">???????? ???????? ???0?1?1 ?0?1?0?1 ?1?0?1?0</span><br><span class="line">?0?1?0?1 11101100 00010001 11101100 00010???</span><br><span class="line">???????? ???????? ???????? ???????? ????????</span><br><span class="line">???????? ???????? ??????0? 0?1?1?1? 0?1?0?1?</span><br><span class="line">0?101000 01110011 10011000 10100010 10011011</span><br><span class="line">11010110 ???????? ???????? ???????? ????????</span><br><span class="line">?1?01101 11001101 01101011 ???????? ????????</span><br><span class="line">???????? ???????? ???????? ?0?10100 ????????</span><br><span class="line">???????? ???????</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="整理信息"><a class="markdownIt-Anchor" href="#整理信息"></a> 整理信息</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;   0100 = 编码模式 8-bit Byte</span><br><span class="line">&gt;   00011100 = 计数器 28</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟前面读取的数据比对一下，可以知道前28个码字都是完整的，这就意味着我们都不需要使用纠错码来纠错，直接读取就行了。</p>
<h4 id="脚本读取"><a class="markdownIt-Anchor" href="#脚本读取"></a> 脚本读取</h4>
<p>最后的解密代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;&#x27;&#x27;01111010 01101010 01100011 0111</span><br><span class="line">01000110 01100111 10110111 10010011 00000111</span><br><span class="line">01010101 11110110 01100011 00010110 11100110</span><br><span class="line">01000101 11110110 11010110 01010101 11110011</span><br><span class="line">00010110 11100101 11110111 00010111 00100110</span><br><span class="line">00110011 00000110 01000011 00110111 1101&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ss = s.replace(&quot; &quot;,&quot;&quot;).replace(&quot;\n&quot;,&quot;&quot;)</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(0,28):</span><br><span class="line">	flag += chr(int(ss[i*8:(i+1)*8],2))</span><br><span class="line">print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将上面的代码运行，即可得到最终的flag。</p>
<h4 id="使用工具恢复"><a class="markdownIt-Anchor" href="#使用工具恢复"></a> 使用工具恢复</h4>
<p>现在我们讲如何使用工具：<br />
从github上将qrzybox-master下载下来，将index.html文件拖入浏览器中打开，然后点击“new project”–&gt; “import from image”，然后将“恢复固定格式.png”导入：<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-55.png" alt="alt text" /></p>
<p>然后点击“tools”–&gt;“Extract QR information”,即可恢复数据:<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-54.png" alt="alt text" /></p>
<p>就这么简单，当然这个工具还有很多其他的用处，就开大家自己去研究了。</p>
<h3 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h3>
<p>二维码生成细节和原理：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21463650">https://zhuanlan.zhihu.com/p/21463650</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/10590.html">https://coolshell.cn/articles/10590.html</a></p>
<p>官方文档（中文版）：</p>
<p><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/ef77275f312b3169a451a4a4.html?pn=50">https://wenku.baidu.com/view/ef77275f312b3169a451a4a4.html?pn=50</a></p>
<p>里德-所罗门码：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8208aad537bb">https://www.jianshu.com/p/8208aad537bb</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Encoding_outline">https://en.wikiversity.org/wiki/Reed–Solomon_codes_for_coders#Encoding_outline</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30363903/optimizing-a-reed-solomon-encoder-polynomial-division">https://stackoverflow.com/questions/30363903/optimizing-a-reed-solomon-encoder-polynomial-division</a></p>
<p>MMA2015-MISC400-qr的write up</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pwning/public-writeup/blob/master/mma2015/misc400-qr/writeup.md">https://github.com/pwning/public-writeup/blob/master/mma2015/misc400-qr/writeup.md</a></p>
<h2 id="modbus中文版"><a class="markdownIt-Anchor" href="#modbus中文版"></a> MODBUS中文版</h2>
<iframe src="/js/pdfjs/web/viewer.html?file=/pdf/modbusxieyi.pdf" width="100%" height="600px"></iframe>
<h2 id="ctfshow-2026元旦跨年欢乐赛-cs2026大佬wp"><a class="markdownIt-Anchor" href="#ctfshow-2026元旦跨年欢乐赛-cs2026大佬wp"></a> CTFSHOW-2026元旦跨年欢乐赛-CS2026大佬wp</h2>
<iframe src="/js/pdfjs/web/viewer.html?file=/pdf/CS2026-zs1994WP.pdf" width="100%" height="600px"></iframe>
<h2 id="演讲服务器端模板注入现代web应用的rce英文版文档"><a class="markdownIt-Anchor" href="#演讲服务器端模板注入现代web应用的rce英文版文档"></a> 演讲《服务器端模板注入：现代Web应用的RCE》英文版文档</h2>
<iframe src="/js/pdfjs/web/viewer.html?file=/pdf/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf" width="100%" height="600px"></iframe>
<h2 id="信息收集-dns解释-layer-fofa"><a class="markdownIt-Anchor" href="#信息收集-dns解释-layer-fofa"></a> 信息收集-DNS解释-layer-fofa</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2401_89464052/article/details/148560131">https://blog.csdn.net/2401_89464052/article/details/148560131</a></li>
</ul>
<p>一.DNS 信息收集</p>
<p>DNS概念：域名与ip被绑定的记录存在在DNS服务器，是进行域名和与之相对应的IP地址转换的服务器。</p>
<p>1、将域名解析为 IP 地址<br />
通过ping命令：ping <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a> -c 3 -4（-c指定发送数据包数量，-4指定使用IPV4）</p>
<p>这里将百度的域名转换为了IP就是110.242.68.66。<br />
DNS解析过程：</p>
<p>&lt;1&gt;.先向根发送请求</p>
<p>&lt;2&gt;.根将xxx.com的预服务器的地址发送给请求端</p>
<p>&lt;3&gt;.对应目标服务器DNS中获取IP地址返回客户端</p>
<p>&lt;4&gt;.向IP地址发送请求</p>
<p>总结：通过域名找IP地址</p>
<p>2.多地ping</p>
<p>站长之家：<a target="_blank" rel="noopener" href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p>
<p>可以显示从全国各地进行ping扫时各地的响应</p>
<p>当你kali：ping不通的时候可以在这里查看，是目标服务器坏了还是你kali网出问题了。<br />
二.域名概念</p>
<p>1.域名分为主域名，一级域名，二级域名，多级域名</p>
<p>例如fjw.com就是主域名，shuai.fjw.com就是一级域名，zhen.shuai.fjw.com就是二级域名。</p>
<p>2.子域名是某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。</p>
<p>3.常见顶级域名：.com(工商金融)/.cn（中国）/.gov.cn（政府）这个碰到了绕道走，进去别说跟我学的。/.edu.cn（教育）/.org(非盈利组织）/.net 网络信息中心</p>
<p>4.通常子域名收集到四级即可不必太多。</p>
<p>三.子域名收集</p>
<p>1.layer-子域名挖掘机</p>
<p>介绍：暴力枚举子域名<br />
！！<a target="_blank" rel="noopener" href="http://xn--a-sm4bu3aq4j1pk13o8o2b2ndlsf.mi.xn--commi-7h1hm73a01f0pwethu4khqvmt8f.com">注意这里我跑的是a.mi.com浏览器上打开却是mi.com</a>,是因为泛解析：***（无论输入什么）.mi.com 都会指向mi.com的主域名。这是网站开发人员设置的。所以你收集到的很多域名都可能是重的。需要你自己去整理。</p>
<p>这里我跑的都是一级域名<br />
2.站长之家子域名查询</p>
<p><a target="_blank" rel="noopener" href="https://tool.chinaz.com/subdomain">https://tool.chinaz.com/subdomain</a><br />
没vip有次数限制，要登陆，感觉一般。</p>
<p>3.google搜索引擎查找</p>
<p>google语法：site:xiaomi.com<br />
搜索出来的结果都是子域名<br />
4.fofa钟馗之眼搜集子域名</p>
<p>网站：<a target="_blank" rel="noopener" href="https://fofa.info/">https://fofa.info/</a><br />
要登陆的，有限制搜索的，</p>
<p>语法：domain=“<a target="_blank" rel="noopener" href="http://xiaomi.com">xiaomi.com</a>”</p>
<h2 id="cheatengineviice教程-自动汇编基础知识"><a class="markdownIt-Anchor" href="#cheatengineviice教程-自动汇编基础知识"></a> 【Cheatengine】Ⅶ：ce教程-自动汇编（基础知识）</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/opus/377368436654250777/?from=readlist">https://www.bilibili.com/opus/377368436654250777/?from=readlist</a></li>
<li>记录作用，如有侵权请联系我删除</li>
</ul>
<p><strong>这个汇编表–部分是我自己的解释，大部分都是从网上down下来的，就不标原创了，虽然我给了很多注解</strong></p>
<p>本章开始前，我们必须先了解一下基本的汇编命令及其含义，才能在自动汇编写出得心应手的代码。实现各种强大的功能。<strong>本教程没有具体内容，可不看，这个表是你在ct的时候拿来查的，仅此而已，背是不可能背下来的</strong></p>
<h3 id="1寄存器"><a class="markdownIt-Anchor" href="#1寄存器"></a> <strong>1.寄存器：</strong></h3>
<p>寄存器通常都用来意指由一个指令之输出或输入可以直接索引到的暂存器群组。更适当的是称他们为“架构寄存器”。</p>
<p>在自动汇编里面，我们会经常用到寄存器，怎么理解呢，就是临时存放东西的一个盒子吧，首先我们了解一下寄存器的种类，嗯，你看不懂的，但其实没关系，只是个名字而已。</p>
<h4 id="一16-位寄存器远古寄存器"><a class="markdownIt-Anchor" href="#一16-位寄存器远古寄存器"></a> <strong>一.16 位寄存器(远古寄存器)</strong></h4>
<p><strong>AX</strong>: 累加器。也能做寄存器</p>
<p><strong>BX</strong>: 空闲寄存器</p>
<p><strong>CX</strong>: 计数器。也能做寄存器</p>
<p><strong>DX</strong>: 数据寄存器。也能做寄存器。</p>
<p><strong>SI</strong>:   源址变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>DI:</strong>  目的变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>BP:</strong> 机制指针寄存器。临时存储ESP，也能做寄存器。</p>
<p><strong>SP:</strong> 原址指针寄存器。堆栈种指向寄存器和地址。</p>
<p><strong>IP:</strong>  指令指针寄存器。</p>
<h4 id="二32-位寄存器常用寄存器"><a class="markdownIt-Anchor" href="#二32-位寄存器常用寄存器"></a> <strong>二.32 位寄存器(常用寄存器)</strong></h4>
<p><strong>EAX:</strong> 累加器。也能做寄存器</p>
<p><strong>EBX:</strong> 空闲寄存器</p>
<p><strong>ECX:</strong> 计数器。也能做寄存器</p>
<p><strong>EDX:</strong> 数据寄存器。也能做寄存器。</p>
<p><strong>ESI:</strong> 源址变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>EDI:</strong> 目的变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>EBP:</strong> 机制指针寄存器。临时存储ESP，也能做寄存器。</p>
<p><strong>ESP:</strong> 原址指针寄存器。堆栈种指向寄存器和地址。</p>
<p><strong>EIP:</strong> 指令指针寄存器。</p>
<h4 id="三64-位寄存器"><a class="markdownIt-Anchor" href="#三64-位寄存器"></a> <strong>三.64 位寄存器</strong></h4>
<p><strong>整数寄存器</strong></p>
<p><strong>RAX:</strong> 累加器。也能做寄存器</p>
<p><strong>RBX:</strong> 空闲寄存器</p>
<p><strong>RCX:</strong> 计数器。也能做寄存器</p>
<p><strong>RDX:</strong> 数据寄存器。也能做寄存器。</p>
<p><strong>R10:R11:</strong> 易失</p>
<p><strong>R12:R15:</strong> 非易失</p>
<p><strong>RSI:</strong> 源址变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>RDI:</strong> 目的变址寄存器。字符串形式的指针，也能做寄存器。</p>
<p><strong>RBP:</strong> 机制指针寄存器。临时存储ESP，也能做寄存器。</p>
<p><strong>RSP:</strong> 原址指针寄存器。堆栈种指向寄存器和地址。</p>
<p><strong>RIP:</strong> 指令指针寄存器。</p>
<p><strong>浮点数寄存器</strong></p>
<p><strong>xmm0:xmm15</strong></p>
<h3 id="2指令"><a class="markdownIt-Anchor" href="#2指令"></a> <strong>2.指令</strong></h3>
<h4 id="一汇编常用指令"><a class="markdownIt-Anchor" href="#一汇编常用指令"></a> <strong>一．汇编常用指令</strong></h4>
<h5 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> cmp</h5>
<ul>
<li><strong>cmp</strong>：**（cmp ax,bx）**的逻辑含义是比较 <strong>ax,bx</strong> 中的值。并且将逻辑比较的结果放入标志寄存器中。
<ul>
<li><strong>解释：</strong> 简单来说，就是比较两个数。然后比较结果放入标志寄存器</li>
</ul>
</li>
</ul>
<h5 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> jmp</h5>
<ul>
<li><strong>Jmp：****（jmp xxxx）</strong> 的逻辑含义是强制跳转到 <strong>xxxx</strong> 这个指令
<ul>
<li><strong>解释：</strong> 简单来说，强行执行<strong>xxxx</strong>这个指令</li>
</ul>
</li>
<li><strong>Jmp 变种：</strong>
<ul>
<li><strong>je/jz:</strong> 标志寄存器的标志的逻辑含义为相等，则强制跳转</li>
<li><strong>jne/jnz:</strong> <strong>标志为不相等</strong>，则强制跳转</li>
</ul>
</li>
</ul>
<p><strong>（注：接下来会出现符号的概念，一般游戏不会有负数，所以有符号可以不看）</strong></p>
<p><strong>ja:</strong>   无符号，其标志为大于，则跳转</p>
<p><strong>jg:</strong>   有符号，其标志为大于，则跳转</p>
<p><strong>jna:</strong>  无符号，其标志为不大于，则跳转</p>
<p><strong>jng:</strong>  有符号，其标志为不大于，则跳转</p>
<p><strong>jb:</strong>   无符号，其标志为小于，则跳转</p>
<p><strong>jl:</strong>   有符号，其标志为小于，则跳转</p>
<p><strong>jnb:</strong>  无符号，其标志为不小于，则跳转</p>
<p><strong>jnl:</strong>  有符号，其标志为不小于，则跳转</p>
<p><strong>jae:</strong>  无符号，其标志为大于等于，则跳转</p>
<p><strong>jge:</strong>  有符号，其标志为大于等于，则跳转</p>
<p><strong>jnae:</strong> 无符号，其标志为不大于等于，则跳转</p>
<p><strong>jnge:</strong> 有符号，其标志为不大于等于，则跳转</p>
<p><strong>例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp [rbx+14],#1</span><br><span class="line">ja originalcode</span><br></pre></td></tr></table></figure>
<p>先比较<strong>rbx+14</strong>这个地址的数值与<strong>1</strong>的大小，如果比较结果为<strong>大于</strong>，那么 <strong>ja originalcode</strong> 这行代码被执行，否则不被执行。</p>
<h5 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> mov</h5>
<ul>
<li>
<p><strong>Mov:</strong></p>
<ul>
<li><strong>（mov eax,ebx）<strong>把 <strong>ebx</strong>这个</strong>地址</strong>（注意不是地址的内容）移动到 <strong>eax</strong>（可以理解成 复制过去）</li>
<li>**（mov eax,[ebx]）**把ebx这个地址里面存放的内容复制到 eax这个地址所存放的内容（理解为赋值）</li>
</ul>
</li>
<li>
<p>注意：[eax]就代表eax这个地址存放的内容</p>
</li>
</ul>
<h5 id="push-pop"><a class="markdownIt-Anchor" href="#push-pop"></a> push &amp; pop</h5>
<ul>
<li>Push 与 pop 大部分情况下都需要搭配使用的</li>
<li><strong>解释：</strong> push中文翻译为入栈，pop为出栈</li>
<li>(那么你会问，什么是栈，把栈想象成一个叠叠乐，入栈就是把一个东西放在叠叠乐的最上面，出栈就是把这个东西从叠叠乐的最上面取出，假如不取出就成为叠叠乐的一部分，叠叠乐很可能会塌)</li>
<li>（Push eax）与（pop eax）分别为入栈指令与出栈指令。</li>
</ul>
<h4 id="二汇编指令大全"><a class="markdownIt-Anchor" href="#二汇编指令大全"></a> <strong>二．汇编指令大全</strong></h4>
<p>本小节内容可以跳过，需要的时候再查，源自x86，x87汇编指令大全 <br />
一、数据传输指令<br />
它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>
<ol>
<li>通用数据传送指令</li>
</ol>
<p><strong>MOV</strong>      送字或字节.</p>
<p><strong>MOVSX</strong>    先符号扩展,再传送.</p>
<p><strong>MOVZX</strong>    先零扩展,再传送.</p>
<p><strong>PUSH</strong>      把字压入堆栈.</p>
<p><strong>POP</strong>       把字弹出堆栈.</p>
<p><strong>PUSHA</strong>     把 AX,CX,DX,BX,SP,BP,SI,DI 依次压入堆栈.</p>
<p><strong>POPA</strong>      把 DI,SI,BP,SP,BX,DX,CX,AX 依次弹出堆栈.</p>
<p><strong>PUSHAD</strong>    把 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 依次压入堆栈.</p>
<p><strong>POPAD</strong>     把 EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX 依次弹出堆栈.</p>
<p><strong>BSWAP</strong>     交换32位寄存器里字节的顺序</p>
<p><strong>XCHG</strong>      交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)</p>
<p><strong>CMPXCHG</strong>  比较并交换操作数.(第二个操作数必须为累加器 AL/AX/EAX)</p>
<p><strong>XADD</strong>      先交换再累加.(结果在第一个操作数里)</p>
<p><strong>XLAT</strong>       字节查表转换.{BX 指向一张 256 字节的表的起点,AL 为表的索引值(0-255,即 0-FFH);返回 AL 为查表结果.([BX+AL]-&gt;AL) }</p>
<ol start="2">
<li>输入输出端口传送指令.</li>
</ol>
<p><strong>IN</strong>         I/O 端口输入. ( 语法: IN   累加器,    {端口号│DX} )</p>
<p><strong>OUT</strong>       I/O 端口输出. ( 语法: OUT {端口号│DX},累加器 )输入输出端口由立即方</p>
<p>式指定时,其范围是 0-255; 由寄存器 DX 指定时,其范围 0-65535.</p>
<ol start="3">
<li>目的地址传送指令.</li>
</ol>
<p><strong>LEA</strong>     装入有效地址.</p>
<p>例: LEA DX,string ;把偏移地址存到 DX.</p>
<p><strong>LDS</strong>     传送目标指针,把指针内容装入 DS.</p>
<p>例: LDS SI,string   ;把段地址:偏移地址存到 DS:SI.</p>
<p><strong>LES</strong>     传送目标指针,把指针内容装入 ES.</p>
<p>例: LES DI,string   ;把段地址:偏移地址存到 ES:DI.</p>
<p><strong>LFS</strong>     传送目标指针,把指针内容装入 FS.</p>
<p>例: LFS DI,string   ;把段地址:偏移地址存到 FS:DI.</p>
<p><strong>LGS</strong>     传送目标指针,把指针内容装入 GS.</p>
<p>例: LGS DI,string   ;把段地址:偏移地址存 到 GS:DI.</p>
<p><strong>LSS</strong>     传送目标指针,把指针内容装入 SS.</p>
<p>例: LSS DI,string   ;把段地址:偏移地址存到 SS:DI.</p>
<ol start="4">
<li>标志传送指令.</li>
</ol>
<p><strong>LAHF</strong>    标志寄存器传送,把标志装入AH.</p>
<p><strong>SAHF</strong>    标志寄存器传送,把AH内容装入标志寄存器.</p>
<p><strong>PUSHF</strong>   标志入栈.</p>
<p><strong>POPF</strong>    标志出栈.</p>
<p><strong>PUSHD</strong>   32 位标志入栈.</p>
<p><strong>POPD</strong>    32 位标志出栈.</p>
<p>二、算术运算指令</p>
<p><strong>ADD</strong>     加法.</p>
<p><strong>ADC</strong>     带进位加法.</p>
<p><strong>INC</strong>     加 1.</p>
<p><strong>AAA</strong>     加法的 ASCII 码调整.</p>
<p><strong>DAA</strong>     加法的十进制调整.</p>
<p><strong>SUB</strong>     减法.</p>
<p><strong>SBB</strong>     带借位减法.</p>
<p><strong>DEC</strong>     减 1.</p>
<p><strong>NEG</strong>     求反(以    0 减之).</p>
<p><strong>CMP</strong>     比较.(两操作数作减法,仅修改标志位,不回送结果).</p>
<p><strong>AAS</strong>     减法的 ASCII 码调整.</p>
<p><strong>DAS</strong>     减法的十进制调整.</p>
<p><strong>MUL</strong>     无符号乘法.结果回送 AH 和 AL(字节运算),或 DX 和 AX(字运算),</p>
<p><strong>IMUL</strong>    整数乘法.结果回送 AH 和 AL(字节运算),或 DX 和 AX(字运算),</p>
<p><strong>AAM</strong>     乘法的 ASCII 码调整.</p>
<p><strong>DIV</strong>     无符号除法.结果回送:商回送 AL,余数回送 AH, (字节运算);或 商回送 AX,余数</p>
<p>回送 DX, (字运算).</p>
<p><strong>IDIV</strong>    整数除法.结果回送:商回送 AL,余数回送 AH, (字节运算);或 商回送 AX,余数回</p>
<p>送 DX, (字运算).</p>
<p><strong>AAD</strong>     除法的 ASCII 码调整.</p>
<p><strong>CBW</strong>     字节转换为字. (把AL中字节的符号扩展到AH 中去)</p>
<p><strong>CWD</strong>     字转换为双字. (把AX 中的字的符号扩展到DX中去)</p>
<p><strong>CWDE</strong>    字转换为双字. (把 AX 中的字符号扩展到 EAX中去)</p>
<p><strong>CDQ</strong>     双字扩展. (把 EAX 中的字的符号扩展到 EDX 中去)三、逻辑运算指令</p>
<p><strong>AND</strong>     与运算.</p>
<p><strong>OR</strong>      或运算.</p>
<p><strong>XOR</strong>     异或运算.</p>
<p><strong>NOT</strong>     取反.</p>
<p><strong>TEST</strong>    测试.(两操作数作与运算,仅修改标志位,不回送结果).</p>
<p><strong>SHL</strong>     逻辑左移.</p>
<p><strong>SAL</strong>     算术左移.(=SHL)</p>
<p><strong>SHR</strong>     逻辑右移.</p>
<p><strong>SAR</strong>     算术右移.(=SHR)</p>
<p><strong>ROL</strong>     循环左移.</p>
<p><strong>ROR</strong>     循环右移.</p>
<p><strong>RCL</strong>     通过进位的循环左移.</p>
<p><strong>RCR</strong>     通过进位的循环右移.</p>
<p><strong>以上八种移位指令,其移位次数可达255次.</strong></p>
<p><strong>移位一次时, 可直接用操作码. 如 SHL AX,1.</strong></p>
<p><strong>移位&gt;1次时, 则由寄存器CL给出移位次数.</strong></p>
<p><strong>如</strong> <strong>MOV CL,04   SHL AX,CL</strong></p>
<p>四、串指令</p>
<p><strong>DS:SI</strong> 源串段寄存器 :源串变址.</p>
<p><strong>ES:DI</strong> 目标串段寄存器:目标串变址.</p>
<p><strong>CX</strong> 重复次数计数器.</p>
<p><strong>AL/AX</strong> 扫描值.</p>
<p>**D(**标志)   0表示重复操作中SI和DI应自动增量; 1表示应自动减量.</p>
<p>**Z(**标志)   用来控制扫描或比较操作的结束.</p>
<p><strong>MOVS</strong>    串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )</p>
<p><strong>CMPS</strong>    串比较.( CMPSB 比较字符. CMPSW 比较字. )</p>
<p><strong>SCAS</strong>    串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位.</p>
<p><strong>LODS</strong>    装入串.把源串中的元素(字或字节)逐一装入 AL 或 AX 中</p>
<p><strong>.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )</strong></p>
<p><strong>STOS</strong>    保存串.是 LODS 的逆过程.</p>
<p><strong>REP</strong>         当 CX/ECX&lt;&gt;0 时重复.</p>
<p><strong>REPE/REPZ</strong>   当 ZF=1 或比较结果相等,且 CX/ECX&lt;&gt;0 时重复.</p>
<p><strong>REPNE/REPNZ</strong> 当 ZF=0 或比较结果不相等,且 CX/ECX&lt;&gt;0 时重复.</p>
<p><strong>REPC</strong>        当 CF=1 且 CX/ECX&lt;&gt;0 时重复.</p>
<p><strong>REPNC</strong>       当 CF=0 且 CX/ECX&lt;&gt;0 时重复.</p>
<p>五、程序转移指令</p>
<ol>
<li>无条件转移指令 (长转移)**</li>
</ol>
<p><strong>JMP</strong>         无条件转移指令</p>
<p><strong>CALL</strong>        过程调用</p>
<p><strong>RET/RETF</strong>    过程返回.</p>
<ol start="2">
<li>条件转移指令   (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )**</li>
</ol>
<p><strong>JA/JNBE</strong>     不小于或不等于时转移.</p>
<p><strong>JAE/JNB</strong>     大于或等于转移.</p>
<p><strong>JB/JNAE</strong>     小于转移.</p>
<p><strong>JBE/JNA</strong>     小于或等于转移.</p>
<p><strong>以上四条,测试无符号整数运算的结果(标志C 和Z).</strong></p>
<p><strong>JG/JNLE</strong>     大于转移.</p>
<p><strong>JGE/JNL</strong>     大于或等于转移.</p>
<p><strong>JL/JNGE</strong>     小于转移.</p>
<p><strong>JLE/JNG</strong>     小于或等于转移.</p>
<p><strong>以上四条,测试带符号整数运算的结果(标志S,O 和 Z).</strong></p>
<p><strong>JE/JZ</strong>       等于转移.</p>
<p><strong>JNE/JNZ</strong>     不等于时转移.</p>
<p><strong>JC</strong>          有进位时转移.</p>
<p><strong>JNC</strong>         无进位时转移.</p>
<p><strong>JNO</strong>         不溢出时转移.</p>
<p><strong>JNP/JPO</strong>     奇偶性为奇数时转移.</p>
<p><strong>JNS</strong>         符号位为 &amp;34; 时转移.</p>
<p><strong>JO</strong>          溢出转移.</p>
<p><strong>JP/JPE</strong>      奇偶性为偶数时转移.</p>
<p><strong>JS</strong>          符号位为 &amp;34; 时转移.</p>
<ol start="3">
<li>循环控制指令(短转移)</li>
</ol>
<p><strong>LOOP</strong>              CX 不为零时循环.</p>
<p><strong>LOOPE/LOOPZ</strong>      CX 不为零且标志 Z=1 时循环.</p>
<p><strong>LOOPNE/LOOPNZ</strong>   CX 不为零且标志 Z=0 时循环.</p>
<p><strong>JCXZ</strong>               CX 为零时转移.</p>
<p><strong>JECXZ</strong>              ECX 为零时转移.</p>
<ol start="4">
<li>中断指令</li>
</ol>
<p><strong>INT</strong>         中断指令</p>
<p><strong>INTO</strong>        溢出中断</p>
<p><strong>IRET</strong>        中断返回</p>
<ol start="5">
<li>处理器控制指令</li>
</ol>
<p><strong>HLT</strong>         处理器暂停,  直到出现中断或复位信号才继续.</p>
<p><strong>WAIT</strong>        当芯片引线TEST 为高电平时使 CPU进入等待状态.</p>
<p><strong>ESC</strong>         转换到外处理器.</p>
<p><strong>LOCK</strong>        封锁总线.</p>
<p><strong>NOP</strong>         空操作.</p>
<p><strong>STC</strong>         置进位标志位.</p>
<p><strong>CLC</strong>         清进位标志位.</p>
<p><strong>CMC</strong>         进位标志取反.</p>
<p><strong>STD</strong>         置方向标志位.</p>
<p><strong>CLD</strong>         清方向标志位.</p>
<p><strong>STI</strong>         置中断允许位.</p>
<p><strong>CLI</strong>         清中断允许位.</p>
<p>六、伪指令</p>
<p><strong>DW</strong>          定义字(2 字节).</p>
<p><strong>PROC</strong>        定义过程.</p>
<p><strong>ENDP</strong>        过程结束.</p>
<p><strong>SEGMENT</strong>     定义段.</p>
<p><strong>ASSUME</strong>      建立段寄存器寻址.</p>
<p><strong>ENDS</strong>        段结束.</p>
<p><strong>END</strong>         程序结束.</p>
<p>七、处理机控制指令：标志处理指令</p>
<p><strong>CLC</strong>     进位位置 0指令</p>
<p><strong>CMC</strong>     进位位求反指令</p>
<p><strong>STC</strong>     进位位置为1指令</p>
<p><strong>CLD</strong>     方向标志置1指令</p>
<p><strong>STD</strong>     方向标志位置1指令</p>
<p><strong>CLI</strong>     中断标志置0 指令</p>
<p><strong>STI</strong>     中断标志置1 指令</p>
<p><strong>NOP</strong>     无操作</p>
<p><strong>HLT</strong>     停机</p>
<p><strong>WAIT</strong>    等待</p>
<p><strong>ESC</strong>     换码</p>
<p><strong>LOCK</strong>    封锁</p>
<h5 id="浮点运算指令集"><a class="markdownIt-Anchor" href="#浮点运算指令集"></a> 浮点运算指令集</h5>
<p>一、控制指令(带 9B 的控制指令前缀 F 变为 FN时浮点不检查，机器码去掉 9B)</p>
<p><strong>FINIT</strong>                 初始化浮点部件                   机器码  9B DB E3</p>
<p><strong>FCLEX</strong>                 清除异常                        机器码  9B DB E2</p>
<p><strong>FDISI</strong>                 浮点检查禁止中断                 机器码  9B DB E1</p>
<p><strong>FENI</strong>                  浮点检查禁止中断二              机器码  9B DB E0</p>
<p><strong>WAIT</strong>                  同步 CPU 和 FPU                 机器码  9B</p>
<p><strong>FWAIT</strong>                 同步 CPU 和 FPU                 机器码  D9 D0</p>
<p><strong>FNOP</strong>                  无操作                         机器码  DA E9</p>
<p><strong>FXCH</strong>                  交换 ST(0)和 ST(1)                机器码  D9 C9</p>
<p><strong>FXCH ST(i)</strong>              交换 ST(0)和 ST(i)                机器码  D9 C1iii</p>
<p><strong>FSTSW ax</strong>              状态字到 ax                     机器码  9B DF E0</p>
<p><strong>FSTSW word ptr mem</strong>   状态字到 mem                   机器码  9B DD mm111mmm</p>
<p><strong>FLDCW word ptr mem</strong>   mem 到状态字                   机器码  D9 mm101mmm</p>
<p><strong>FSTCW word ptr mem</strong>  控制字到 mem                    机器码  9B D9 mm111mmm</p>
<p><strong>FLDENV word ptr mem</strong>   mem 到全环境                   机器码  D9 mm100mmm</p>
<p><strong>FSTENV word ptr mem</strong>  全环境到 mem                    机器码  9B D9 mm110mmm</p>
<p><strong>FRSTOR  word ptr mem</strong>  mem 到 FPU 状态                机器码  DD mm100mmm</p>
<p><strong>FSAVE   word ptr mem</strong>  FPU 状态到 mem                机器码  9B DD mm110mmm</p>
<p><strong>FFREE ST(i)</strong>           标志 ST(i)未使用                   机器码  DD C0iii</p>
<p><strong>FDECSTP</strong>               减少栈指针 1-&gt;0 2-&gt;1             机器码  D9 F6</p>
<p><strong>FINCSTP</strong>               增加栈指针 0-&gt;1 1-&gt;2             机器码  D9 F7</p>
<p><strong>FSETPM</strong>                浮点设置保护                       机器码  DB E4</p>
<p>二、数据传送指令</p>
<p><strong>FLDZ</strong>                  将 0.0 装入 ST(0)                  机器码  D9 EE</p>
<p><strong>FLD1</strong>                  将 1.0 装入 ST(0)                  机器码  D9 E8</p>
<p><strong>FLDPI</strong>                 将 π 装入 ST(0)                    机器码  D9 EB</p>
<p><strong>FLDL2T</strong>                将 ln10/ln2 装入 ST(0)             机器码  D9 E9</p>
<p><strong>FLDL2E</strong>                将 1/ln2 装入 ST(0)                机器码  D9 EA</p>
<p><strong>FLDLG2</strong>                将 ln2/ln10 装入 ST(0)             机器码  D9 EC</p>
<p><strong>FLDLN2</strong>                将 ln2 装入 ST(0)                  机器码  D9 ED</p>
<p><strong>FLD    real4 ptrm em</strong>  装入 mem 的单精度浮点数            机器码  D9 mm000mmm</p>
<p><strong>FLD    real8p trm em</strong>  装入mem的双精度浮点数            机器码  DD mm000mmm</p>
<p><strong>FLD   real10p trm em</strong>  装入 mem 的十字节浮点数            机器码  DB mm101mmm</p>
<p><strong>FILD    word ptr mem</strong>  装入 mem 的二字节整数             机器码  DF mm000mmm</p>
<p><strong>FILD   dword ptr mem</strong>  装入 mem 的四字节整数             机器码  DB mm000mmm</p>
<p><strong>FILD   qword ptr mem</strong>  装入 mem 的八字节整数             机器码  DF mm101mmm</p>
<p><strong>FBLD   tbyte ptr mem</strong>  装入mem的十字节BCD数            机器码  DF mm100mmm</p>
<p><strong>FST    real4 ptr mem</strong>  保存单精度浮点数到mem             机器码  D9 mm010mmm</p>
<p><strong>FST    real8 ptr mem</strong>  保存双精度浮点数到 mem            机器码  DD mm010mmm</p>
<p><strong>FIST    word ptr mem</strong>  保存二字节整数到 mem              机器码  DF mm010mmm</p>
<p><strong>FIST   dword ptr mem</strong>  保存四字节整数到 mem              机器码  DB mm010mmm</p>
<p><strong>FSTP   real4 ptr mem</strong>  保存单精度浮点数到 mem 并出栈      机器码  D9 mm011mmm</p>
<p><strong>FSTP   real8 ptr mem</strong>  保存双精度浮点数到 mem 并出栈      机器码  DD mm011mmm</p>
<p><strong>FSTP  real10 ptr mem</strong>  保存十字节浮点数到 mem 并出栈      机器码  DB mm111mmm</p>
<p><strong>FISTP   word ptr mem</strong>  保存二字节整数到mem并出栈        机器码  DF mm011mmm</p>
<p><strong>FISTP  dword ptr mem</strong>  保存四字节整数到 mem 并出栈       机器码  DB mm011mmm</p>
<p><strong>FISTP  qword ptr mem</strong>  保存八字节整数到mem并出栈        机器码  DF mm111mmm</p>
<p><strong>FBSTP  tbyte ptr mem</strong>  保存十字节 BCD 数到 mem 并出栈     机器码  DF mm110mmm</p>
<p><strong>FCMOVB</strong>                ST(0),ST(i) &lt;时传送              机器码  DA C0iii</p>
<p><strong>FCMOVBE</strong>               ST(0),ST(i) &lt;=时传送             机器码  DA D0iii</p>
<p><strong>FCMOVE</strong>                ST(0),ST(i) =时传送             机器码  DA C1iii</p>
<p><strong>FCMOVNB</strong>               ST(0),ST(i) &gt;=时传送             机器码  DB C0iii</p>
<p><strong>FCMOVNBE</strong>              ST(0),ST(i) &gt;时传送              机器码  DB D0iii</p>
<p><strong>FCMOVNE</strong>               ST(0),ST(i) !=时传送            机器码  DB C1iii</p>
<p><strong>FCMOVNU</strong>               ST(0),ST(i) 有序时传送        机器码  DB D1iii</p>
<p><strong>FCMOVU</strong>                ST(0),ST(i) 无序时传送        机器码  DA D1iii</p>
<p>三、比较指令</p>
<p><strong>FCOM</strong>                  ST(0)-ST(1)                   机器码  D8 D1</p>
<p><strong>FCOMI</strong>                 ST(0),ST(i)  ST(0)-ST(1)         机器码  DB F0iii</p>
<p><strong>FCOMIP</strong>                ST(0),ST(i)  ST(0)-ST(1)并出栈   机器码  DF F0iii</p>
<p><strong>FCOM   real4 ptr mem</strong>  ST(0)-实数 mem                机器码  D8 mm010mmm</p>
<p><strong>FCOM   real8 ptr mem</strong>  ST(0)-实数 mem                机器码  DC mm010mmm</p>
<p><strong>FICOM   word ptr mem</strong>  ST(0)-整数 mem                机器码  DE mm010mmm</p>
<p><strong>FICOM  dword ptr mem</strong>  ST(0)-整数 mem                机器码  DA mm010mmm</p>
<p><strong>FICOMP  word ptr mem</strong>  ST(0)-整数 mem 并出栈         机器码  DE mm011mmm</p>
<p><strong>FICOMP dword ptr mem</strong>  ST(0)-整数 mem 并出栈            机器码  DA mm011mmm</p>
<p><strong>FTST</strong>                  ST(0)-0                          机器码  D9 E4</p>
<p><strong>FUCOM  ST(i)</strong>          ST(0)-ST(i)                      机器码  DD E0iii</p>
<p><strong>FUCOMP ST(i)</strong>          ST(0)-ST(i)并出栈                   机器码  DD E1iii</p>
<p><strong>FUCOMPP</strong>               ST(0)-ST(1)并二次出栈             机器码  DA E9</p>
<p><strong>FXAM</strong>                  ST(0)规格类型                    机器码  D9 E5</p>
<p>四、运算指令</p>
<p><strong>FADD</strong>                  把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器)  相加，并将结果存入目的操作数</p>
<p><strong>FADDP  ST(i),ST</strong>       这个指令是使目的操作数加上 ST  缓存器，并弹出 ST 缓存器，而 目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了</p>
<p><strong>FIADD</strong>                 FIADD 是把 ST   加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数</p>
<p><strong>FSUB</strong>                  减</p>
<p><strong>FSUBP</strong></p>
<p><strong>FSUBR</strong>                 减数与被减数互换</p>
<p><strong>FSUBRP</strong></p>
<p><strong>FISUB</strong></p>
<p><strong>FISUBR</strong></p>
<p><strong>FMUL</strong>                  乘</p>
<p><strong>FMULP</strong></p>
<p><strong>FIMUL</strong></p>
<p><strong>FDIV</strong>                  除</p>
<p><strong>FDIVP</strong></p>
<p><strong>FDIVR</strong></p>
<p><strong>FDIVRP</strong></p>
<p><strong>FIDIV</strong></p>
<p><strong>FIDIVR</strong></p>
<p><strong>FCHS</strong>                  改变 ST 的正负值</p>
<p><strong>FABS</strong>                  把 ST  之值取出，取其绝对值后再存回去。</p>
<p><strong>FSQRT</strong>                 将 ST  之值取出，开根号后再存回去。</p>
<p><strong>FSCALE</strong>                这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1)   之值不变。ST(1)  必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1)    会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。</p>
<p><strong>FRNDINT</strong>               这个指令是把 ST 的数值舍入成整数，FPU    提供四种舍入方式，由 FPU 的控制字组(control    word)中的 RC 两个位决定</p>
<p><strong>RC</strong>    舍入控制</p>
<p>00    四舍五入</p>
<p>01    向负无限大舍入</p>
<p>10    向正无限大舍入</p>
<p>11    向零舍去</p>
<h3 id="3函数"><a class="markdownIt-Anchor" href="#3函数"></a> <strong>3.函数</strong></h3>
<p>ce的函数实在是不多，毕竟不是一款编程语言，但，我们还是有必要了解下</p>
<p><strong>a. alloc</strong></p>
<p>用法：alloc（xxx,2048）</p>
<p><strong>解释：</strong> 自动划分一块大小为2048的内存，并命名为xxx</p>
<p><strong>b. label</strong></p>
<p>用法：label（xxx）</p>
<p><strong>解释：</strong> 定义一个标签，这个标签可以包含需要的指令</p>
<p>alloc与 label 的区别：二者都可以理解为定义了一个标签，区别在于，alloc定义的标签 是可以放进内存空间的（也就是放进程序里执行），而label定义的标签，只是具有标签的含义，放不进内存空间里面，一般来说，alloc定义的标签里面可以放label以达到你想要的目的。（简单来说，标签相当于一段代码的缩写，用很短的代码表示很长的一段汇编指令）</p>
<p><strong>c. registersymbol</strong></p>
<p>用法：registersymbol（xxx）</p>
<p><strong>解释：</strong> 为你分配的内存空间取一个可以全局调用的名称，这个名称除了在自动汇编这个</p>
<p>脚本内使用外，还能在类似于手动添加地址的外部操作中使用。</p>
<p><strong>d. aobscan</strong></p>
<p>用法：aobscan（xx,FF FF FF）</p>
<p><strong>解释：</strong> 找到含义 FF FF FF 这段字节数组的汇编代码的地址，并将其赋值给 xx（此时 xx 就代表了哪一个地址）（注意，FF FF FF为特征码，我在后面的ct表会详细讲诉这个函数的具体用法）</p>
<p><strong>e. dealloc</strong></p>
<p>用法：dealloc（xxx）</p>
<p><strong>解释：</strong> 释放之前 alloc 分配的内存</p>
<p><strong>f. unregistersymbol(xxx)</strong></p>
<p>用法：unregistersymbol（xxx）</p>
<p><strong>解释：</strong> 解除定义的全局变量xxx.</p>
<p><strong>g. [ENABLE]与[DISABLE]</strong></p>
<p>用法：搭配使用</p>
<p><strong>解释：</strong> 若脚本被激活，那么执行[ENABLE]下的代码；若脚本被取消激活，那么执行[DISABLE]下的所有代码</p>
<h2 id="wireshark网络分析就这么简单"><a class="markdownIt-Anchor" href="#wireshark网络分析就这么简单"></a> 《Wireshark网络分析就这么简单》</h2>
<iframe src="/js/pdfjs/web/viewer.html?file=/pdf/Wireshark-book.pdf" width="100%" height="600px"></iframe>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/fragrantveget/iqit07/ozmptxh5fg7gbv7x#%E3%80%8A%E5%9F%BA%E4%BA%8E%E3%80%8AWireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%E3%80%8B%E4%B8%80%E4%B9%A6%E5%AF%B9wireshark%E7%9A%84%E5%AD%A6%E4%B9%A0%E3%80%8B">https://www.yuque.com/fragrantveget/iqit07/ozmptxh5fg7gbv7x#《基于《Wireshark网络分析就这么简单》一书对wireshark的学习》</a></li>
<li>基于天宇同志文章的笔记</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-56.png" alt="alt text" /></p>
<blockquote>
<p>双击该网卡选项就会自动对本机进行流量抓包</p>
</blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-57.png" alt="alt text" /></p>
<p>问题：两台服务器A和B的网络配置如下，B的子网掩码本应该是255.255.255.0，被不小心配成了255.255.255.254，它们还能正常通信吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器A:</span><br><span class="line">IP地址：192.168.26.129</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">默认网关：192.168.26.2</span><br><span class="line">服务器B:</span><br><span class="line">IP地址：192.168.26.3</span><br><span class="line">子网掩码：255.255.255.224</span><br><span class="line">默认网关：192.168.26.2</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器B ping服务器A的过程抓包</li>
</ul>
<ol>
<li>服务器B通过ARP广播查询默认网关192.168.26.2的MAC地址<br />
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0_image-58.png" alt="alt text" /></li>
</ol>
<ul>
<li>为什么我ping的是服务器A的IP，B却去查询默认网关的MAC地址呢？</li>
<li>这是因为B根据自己的子网掩码计算出A属于不同子网，跨子网通信需要默认网关的转发，而要和默认网关通信，就需要获得其MAC地址</li>
<li><a href="/posts/2f862a25/#%E7%BD%91%E7%BB%9C">点击跳转子网掩码的知识点</a></li>
</ul>
<ol start="2">
<li>默认网关192.168.26.2向B回复了自己的MAC地址</li>
</ol>
<ul>
<li>
<p>MAC地址的前3个字节标识厂商</p>
</li>
<li>
<p>00:50:56和00:0c:29都被分配给了Vmware公司（全球统一的标准）</p>
</li>
<li>
<p>后面找时间再看</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34595352/article/details/111989105">https://blog.csdn.net/qq_34595352/article/details/111989105</a><br />
<a target="_blank" rel="noopener" href="https://www.yuque.com/fragrantveget/iqit07/ozmptxh5fg7gbv7x#%E3%80%8A%E5%9F%BA%E4%BA%8E%E3%80%8AWireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%E3%80%8B%E4%B8%80%E4%B9%A6%E5%AF%B9wireshark%E7%9A%84%E5%AD%A6%E4%B9%A0%E3%80%8B">https://www.yuque.com/fragrantveget/iqit07/ozmptxh5fg7gbv7x#《基于《Wireshark网络分析就这么简单》一书对wireshark的学习》</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://luoyinhui.github.io">luoyinhui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://luoyinhui.github.io/posts/73235239/">https://luoyinhui.github.io/posts/73235239/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://luoyinhui.github.io" target="_blank">落殷回的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><div class="post-share"><div class="social-share" data-image="/img/shouye.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.6" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js?v=1.1.6" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weixin.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/weixin.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zhifubao.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/zhifubao.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/posts/68fb8f3a/" title="【雨蓝】雨蓝的服务器操作存档"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="onerror=null;src='/img/404.webp'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【雨蓝】雨蓝的服务器操作存档</div></div></div></a><a class="pagination-related" href="/posts/fada0b27/" title="【转载】文件包含"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="onerror=null;src='/img/404.webp'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【转载】文件包含</div></div><div class="info-2"><div class="info-item-1"> x01、什么是文件包含? 为了更好地使用代码的重用性，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码，简单点来说就是一个文件里面包含另外一个或多个文件。  0x02、漏洞成因 文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。  0x03、php引发文件包含漏洞的四个函数 include()include_once()require()require_once()include()和require()的区别：require()如果在包含过程中出错，就会直接退出，不执行后续语句require()如果在包含过程中出错，只会提出警告，但不影响后续语句的执行  0x04、文件包含漏洞分类 4.1、本地文件包含漏洞顾名思义，指的是能打开并包含本地文件的漏洞。大多数情况下遇到的文件包含漏洞都是本地文件包含漏洞。 示例4.1： 以DVWA的靶场环境为例，靶场地址：http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file1.php  把DVWA Security...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/df378f2/" title="【转载】cty笔记转载"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-10</div><div class="info-item-2">【转载】cty笔记转载</div></div><div class="info-2"><div class="info-item-1"> 一句话木马相关命令执行  语句  system()  执行外部程序(命令行)并返回命令输出的第一行为字符串. 失败返回 false,如果没有找到命令返回空字符串.   passthru() 与 system()不同，passthru()直接把命令执行的结果输出到标准输出,而不返回. shell_exec()  返回输出第一行的内容,无回显.需要反弹 shell 使用.   exec()  不回显,返回命令执行的结果.   ``  在 php 中,反引号&quot;`”是可以执行系统命令的. 反引号和 shell_exec()等价     命令执行  解法  解法1：passthru  ?c=passthru(“tac%20fla*”);     解法2：绕过*号  假如*号被过滤了，我们可以通过?c=passthru(“ls”); 先获取flag.php是目标，然后再通过？来匹配单个字母，也就是fla???匹配flag.php ?c=passthru(“tac%20fla???”);   解法3：反字节符配合echo  ?c=echo(ls); ?c=echo%20tac%20...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="avatar"/></div><div class="author-info-name">luoyinhui</div><div class="author-info-description">记录踩坑与瞎折腾，由Hexo+Github搭建</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luoyinhui"><i class="fab fa-github"></i><span>Follow Me</span></a><a class="card-info-btn" href="/subscribe"><i class="fas fa-rss"></i><span>订阅RSS</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-text"> 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E4%BA%8B"><span class="toc-text"> 记事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hexo%E7%9A%84%E5%A4%9A%E7%A7%8Dmarkdown%E6%B8%B2%E6%9F%93%E5%99%A8%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-text"> hexo的多种markdown渲染器对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-hexo-renderer-marked"><span class="toc-text"> 1.1、hexo-renderer-marked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-hexo-renderer-kramed"><span class="toc-text"> 1.2、hexo-renderer-kramed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-hexo-renderer-pandoc"><span class="toc-text"> 1.3、hexo-renderer-pandoc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-hexo-renderer-markdown-it"><span class="toc-text"> 1.4、hexo-renderer-markdown-it</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-hexo-renderer-markdown-it-plus"><span class="toc-text"> 1.5、hexo-renderer-markdown-it-plus</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip%E5%B7%B2%E7%9F%A5%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8"><span class="toc-text"> ZIP已知明文攻击深入利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E6%A6%82%E5%86%B5"><span class="toc-text"> 传统明文攻击概况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-text"> 本文攻击方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bkcrack%E5%AE%9E%E6%93%8D"><span class="toc-text"> bkcrack实操</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E6%96%87%E6%9C%AC%E7%A0%B4%E8%A7%A3"><span class="toc-text"> 加密文本破解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8png%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B4%E7%A0%B4%E8%A7%A3"><span class="toc-text"> 利用PNG图片文件头破解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8zip%E6%A0%BC%E5%BC%8F%E7%A0%B4%E8%A7%A3"><span class="toc-text"> 利用zip格式破解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%A0%B4%E8%A7%A3"><span class="toc-text"> EXE文件格式破解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%8C%85pcapng%E6%A0%BC%E5%BC%8F%E8%A7%A3%E5%AF%86"><span class="toc-text"> 流量包pcapng格式解密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%A0%B4%E8%A7%A3"><span class="toc-text"> 网站相关文件破解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#svg%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%A0%B4%E8%A7%A3"><span class="toc-text"> SVG文件格式破解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn%E4%B9%8B%E6%9C%80relro%E6%9C%80%E5%B0%8F%E4%B8%91%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text"> 【pwn之最】RELRO:最小丑的机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E5%85%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Brelro"><span class="toc-text"> 0、先简单介绍一下RELRO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Brelro%E7%9A%84%E4%B8%89%E4%B8%AA%E7%AD%89%E7%BA%A7"><span class="toc-text"> 1、介绍一下RELRO的三个等级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1no-relro"><span class="toc-text"> （1）no relro</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2partial-relro"><span class="toc-text"> （2）partial relro</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3full-relro"><span class="toc-text"> （3）full relro</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E5%90%8E%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgcc%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-text"> 2、最后介绍一下gcc编译指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rc4"><span class="toc-text"> RC4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rc4-2"><span class="toc-text"> RC4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text"> 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B9%8Bqr%E7%A0%81%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D"><span class="toc-text"> 二维码之QR码生成原理与损坏修复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text"> 二维码基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qr-%E7%A0%81%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-text"> QR 码的格式与生成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#qr%E7%A0%81%E7%9A%84%E5%B0%BA%E5%AF%B8"><span class="toc-text"> QR码的尺寸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#qr%E7%A0%81%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text"> QR码的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%9B%BE%E6%A1%88"><span class="toc-text"> 定位图案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E4%BF%A1%E6%81%AF"><span class="toc-text"> 格式信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-text"> 版本信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A0%81%E5%AD%97%E5%92%8C%E7%BA%A0%E9%94%99%E7%A0%81%E5%AD%97"><span class="toc-text"> 数据码字和纠错码字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-text"> 数据编码与编码流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#qr%E7%A0%81%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81"><span class="toc-text"> QR码支持的数据编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="toc-text"> 示例一：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="toc-text"> 示例二：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%92%8C%E8%A1%A5%E9%BD%90%E7%AC%A6"><span class="toc-text"> 结束符和补齐符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A0%E9%94%99%E7%A0%81"><span class="toc-text"> 纠错码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remainder-bits%E5%89%A9%E4%BD%99%E4%BD%8D"><span class="toc-text"> Remainder Bits（剩余位）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81%E4%B9%9F%E5%8F%AB%E6%8E%A9%E6%A8%A1"><span class="toc-text"> 掩码（也叫掩模）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E7%BB%98%E4%BA%8C%E7%BB%B4%E7%A0%81"><span class="toc-text"> 手绘二维码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A1%AB%E5%85%85%E6%A8%A1%E6%9D%BF"><span class="toc-text"> 准备固定格式的填充模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81"><span class="toc-text"> 进行数据编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%BA%A0%E9%94%99%E7%A0%81"><span class="toc-text"> 计算纠错码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%81%E5%AD%97%E6%95%B4%E7%90%86"><span class="toc-text"> 码字整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85"><span class="toc-text"> 数据填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%8E%A9%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="toc-text"> 与掩码进行异或运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E7%BB%98%E5%AE%8C%E6%88%90"><span class="toc-text"> 手绘完成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mma2015-misc400-qr%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%81%A2%E5%A4%8D%E6%8C%91%E6%88%98"><span class="toc-text"> MMA2015-MISC400-qr二维码恢复挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-text"> 题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%A0%BC%E5%BC%8F%E4%BF%A1%E6%81%AF"><span class="toc-text"> 获取格式信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E7%A0%81%E5%AD%97"><span class="toc-text"> 获取原始码字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%9A%E5%9C%B0%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text"> 尽可能多地恢复数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E6%81%A2%E5%A4%8D"><span class="toc-text"> 编写脚本恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-text"> 拆分和解码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%81%A2%E5%A4%8D%E6%8C%91%E6%88%98-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7"><span class="toc-text"> 二维码恢复挑战-二维码恢复工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-2"><span class="toc-text"> 题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E5%B7%B2%E7%9F%A5%E4%BF%A1%E6%81%AF"><span class="toc-text"> 整理已知信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%88%9D%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-text"> 恢复初始数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%A0%81%E5%AD%97"><span class="toc-text"> 读取数据码字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E4%BF%A1%E6%81%AF"><span class="toc-text"> 整理信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96"><span class="toc-text"> 脚本读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%81%A2%E5%A4%8D"><span class="toc-text"> 使用工具恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text"> 参考文章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modbus%E4%B8%AD%E6%96%87%E7%89%88"><span class="toc-text"> MODBUS中文版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ctfshow-2026%E5%85%83%E6%97%A6%E8%B7%A8%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B-cs2026%E5%A4%A7%E4%BD%ACwp"><span class="toc-text"> CTFSHOW-2026元旦跨年欢乐赛-CS2026大佬wp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%AE%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E7%8E%B0%E4%BB%A3web%E5%BA%94%E7%94%A8%E7%9A%84rce%E8%8B%B1%E6%96%87%E7%89%88%E6%96%87%E6%A1%A3"><span class="toc-text"> 演讲《服务器端模板注入：现代Web应用的RCE》英文版文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-dns%E8%A7%A3%E9%87%8A-layer-fofa"><span class="toc-text"> 信息收集-DNS解释-layer-fofa</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cheatengineviice%E6%95%99%E7%A8%8B-%E8%87%AA%E5%8A%A8%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text"> 【Cheatengine】Ⅶ：ce教程-自动汇编（基础知识）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text"> 1.寄存器：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8016-%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9C%E5%8F%A4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text"> 一.16 位寄存器(远古寄存器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C32-%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text"> 二.32 位寄存器(常用寄存器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8964-%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text"> 三.64 位寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%8C%87%E4%BB%A4"><span class="toc-text"> 2.指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%B1%87%E7%BC%96%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text"> 一．汇编常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cmp"><span class="toc-text"> cmp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jmp"><span class="toc-text"> jmp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mov"><span class="toc-text"> mov</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#push-pop"><span class="toc-text"> push &amp; pop</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8"><span class="toc-text"> 二．汇编指令大全</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text"> 浮点运算指令集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0"><span class="toc-text"> 3.函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95"><span class="toc-text"> 《Wireshark网络分析就这么简单》</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ca0b6d29/" title="【比赛】2026-n1ctf"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="【比赛】2026-n1ctf"/></a><div class="content"><a class="title" href="/posts/ca0b6d29/" title="【比赛】2026-n1ctf">【比赛】2026-n1ctf</a><time datetime="2026-01-26T05:55:34.000Z" title="发表于 2026-01-26 13:55:34">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e9d937e1/" title="【比赛】2026-unictf"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="【比赛】2026-unictf"/></a><div class="content"><a class="title" href="/posts/e9d937e1/" title="【比赛】2026-unictf">【比赛】2026-unictf</a><time datetime="2026-01-25T02:47:01.000Z" title="发表于 2026-01-25 10:47:01">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7909bf57/" title="【比赛】2026-LilacCTF"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="【比赛】2026-LilacCTF"/></a><div class="content"><a class="title" href="/posts/7909bf57/" title="【比赛】2026-LilacCTF">【比赛】2026-LilacCTF</a><time datetime="2026-01-24T08:09:29.000Z" title="发表于 2026-01-24 16:09:29">2026-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c71804a4/" title="【比赛】2024-fic"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="【比赛】2024-fic"/></a><div class="content"><a class="title" href="/posts/c71804a4/" title="【比赛】2024-fic">【比赛】2024-fic</a><time datetime="2026-01-22T12:07:39.000Z" title="发表于 2026-01-22 20:07:39">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fbad44e5/" title="【笔记】re-分享会"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shouye.png" onerror="this.onerror=null;this.src='/img/404.webp'" alt="【笔记】re-分享会"/></a><div class="content"><a class="title" href="/posts/fbad44e5/" title="【笔记】re-分享会">【笔记】re-分享会</a><time datetime="2026-01-22T00:48:59.000Z" title="发表于 2026-01-22 08:48:59">2026-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By luoyinhui</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.0"></script><script src="/js/main.js?v=5.5.0"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js?v=1.1.0"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js?v=19.1.3"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-vercel01.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-vercel01.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('/pluginsSrc/twikoo/dist/twikoo.all.min.js?v=1.6.44').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js?v=1.1.6" async="async" mobile="false"></script><link rel="stylesheet" href="/pluginsSrc/aplayer/dist/APlayer.min.css?v=1.10.1" media="print" onload="this.media='all'"><script src="/pluginsSrc/aplayer/dist/APlayer.min.js?v=1.10.1"></script><script src="/pluginsSrc/butterfly-extsrc/metingjs/dist/Meting.min.js?v=1.1.6"></script><div class="aplayer no-destroy" id="global-aplayer"></div><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script>(function(){
  if (window.__globalAPlayer__) return;
  function init(){
    var el=document.getElementById('global-aplayer');
    if (!el || !window.APlayer) { setTimeout(init, 100); return; }
    window.__globalAPlayer__ = new APlayer({
      container: el,
      fixed: true,
      autoplay: false,
      preload: 'none',
      storageName: 'aplayer-setting-global',
      lrcType: 0,
      audio: [{
        name: '簇拥烈日的花 - 迟里乌布',
        artist: 'Unknown',
        url: '/audio/flower.flac',
        cover: '/img/music-cover.png',
        type: 'auto'
      }]
    });
    try { window.__globalAPlayer__.audio && (window.__globalAPlayer__.audio.playbackRate = 1) } catch(e){}
  }
  init();
})()</script><script src="/pluginsSrc/pjax/pjax.min.js?v=0.2.8"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-switch"><span class="search-switch-item active" data-type="local">本地搜索</span><span class="search-switch-item" data-type="algolia">Algolia</span></div><div id="local-search-panel"><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="algolia-search-panel" style="display:none"><div id="algolia-search-input"><div class="ais-SearchBox"><form class="ais-SearchBox-form" action="" role="search" novalidate=""><input class="ais-SearchBox-input" type="search" placeholder="搜索文章" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" maxlength="512" aria-label="Search"><button class="ais-SearchBox-submit" type="submit" title="Submit the search query" style="display:none;"><svg class="ais-SearchBox-submitIcon" width="10" height="10" viewBox="0 0 40 40" aria-hidden="true"><path d="M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z"></path></svg></button></form></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"><div id="algolia-hits-empty" style="display:none;"></div><div class="ais-Hits" style="display:none;"><ol class="ais-Hits-list"></ol></div></div></div><div class="ais-Pagination" id="algolia-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="algolia-info"><span class="ais-Stats-text"></span><span class="algolia-poweredBy-text">Search powered by Algolia</span></div></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.0"></script><script src="/pluginsSrc/algoliasearch/dist/lite/builds/browser.umd.js?v=5.37.0"></script><script src="/js/search/algolia.js?v=5.5.0"></script></div><!-- hexo injector body_end start --><script>window.toggleHistory = function(btn) {
  var history = document.getElementById('updates-history');
  if (history.style.display === 'none') {
    history.style.display = 'block';
    btn.innerText = '收起';
  } else {
    history.style.display = 'none';
    btn.innerText = '显示更多';
  }
}
</script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper-outer" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="background:url(../assets/preview.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-12-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/35b57171/&quot;);" href="javascript:void(0);" alt="">【项目】hexo-butterfly-updates-heatmap插件介绍</a><div class="blog-slider__text">参考语雀热力图制作的hexo热力图插件~~（嘶后面发现和github热力图也很像）</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(/img/shouye.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ef1d4e7/&quot;);" href="javascript:void(0);" alt="">【笔记】markdown-github+vscode使用文档</a><div class="blog-slider__text">markdown语法在基于github+vscode背景下的使用与探索笔记</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(/img/shouye.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-12-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/989aec00/&quot;);" href="javascript:void(0);" alt="">【刷题】青少年靶场练习</a><div class="blog-slider__text">初步接触应急响应题目，跟随强帝步伐嘻嘻~~</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(/img/shouye.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-08-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c3315bb0/&quot;);" href="javascript:void(0);" alt="">【笔记】十六进制文件头尾特征</a><div class="blog-slider__text">重要的misc知识点！！！</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(/img/shouye.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2025-11-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f2309c58/&quot;);" href="javascript:void(0);" alt="">任务清单</a><div class="blog-slider__text">什么？！我还有那么多活没干呀，快干！！！</div></div></div><div class="blog-slider__item swiper-slide" style="background:url(/img/shouye.png);border-radius:0;opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><div class="blog-slider__content"><span class="blog-slider__code">2026-01-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eb9d2e41/&quot;);" href="javascript:void(0);" alt="">阶段小结</a><div class="blog-slider__text">乱七八糟没有逻辑的反思，要是不小心折磨了你的眼睛非常抱歉ㅍ_ㅍ</div></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div><div class="swiper-button-prev"></div><div class="swiper-button-next"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = '/links/,/link/'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="/js/swiper/swiper.min.js"></script><script defer data-pjax src="/js/swiper/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>